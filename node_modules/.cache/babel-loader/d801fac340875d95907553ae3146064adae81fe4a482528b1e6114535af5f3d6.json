{"ast":null,"code":"import _toConsumableArray from \"/workspaces/Backwoodaroma/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nexport var sortRowTree = function sortRowTree(params) {\n  var rowIds = params.rowIds,\n    rowTree = params.rowTree,\n    disableChildrenSorting = params.disableChildrenSorting,\n    sortRowList = params.sortRowList;\n  var sortedRows = []; // Group the rows by parent\n\n  var groupedByParentRows = new Map([[null, {\n    body: [],\n    footer: null\n  }]]);\n  for (var i = 0; i < rowIds.length; i += 1) {\n    var rowId = rowIds[i];\n    var node = rowTree[rowId];\n    var group = groupedByParentRows.get(node.parent);\n    if (!group) {\n      group = {\n        body: [],\n        footer: null\n      };\n      groupedByParentRows.set(node.parent, group);\n    }\n    if (node.position === 'footer') {\n      group.footer = node;\n    } else {\n      group.body.push(node);\n    }\n  } // Apply the sorting to each list of children\n\n  var sortedGroupedByParentRows = new Map();\n  groupedByParentRows.forEach(function (group, parent) {\n    if (group.body.length === 0) {\n      sortedGroupedByParentRows.set(parent, []);\n    } else {\n      var groupSortedRows;\n      var depth = group.body[0].depth;\n      if (depth > 0 && disableChildrenSorting || !sortRowList) {\n        groupSortedRows = group.body.map(function (row) {\n          return row.id;\n        });\n      } else {\n        groupSortedRows = sortRowList(group.body);\n      }\n      if (group.footer != null) {\n        groupSortedRows.push(group.footer.id);\n      }\n      sortedGroupedByParentRows.set(parent, groupSortedRows);\n    }\n  }); // Flatten the sorted lists to have children just after their parent\n\n  var insertRowListIntoSortedRows = function insertRowListIntoSortedRows(startIndex, rowList) {\n    sortedRows = [].concat(_toConsumableArray(sortedRows.slice(0, startIndex)), _toConsumableArray(rowList), _toConsumableArray(sortedRows.slice(startIndex)));\n    var treeSize = 0;\n    rowList.forEach(function (rowId) {\n      treeSize += 1;\n      var children = sortedGroupedByParentRows.get(rowId);\n      if (children != null && children.length) {\n        var subTreeSize = insertRowListIntoSortedRows(startIndex + treeSize, children);\n        treeSize += subTreeSize;\n      }\n    });\n    return treeSize;\n  };\n  insertRowListIntoSortedRows(0, sortedGroupedByParentRows.get(null));\n  return sortedRows;\n};","map":{"version":3,"names":["sortRowTree","params","rowIds","rowTree","disableChildrenSorting","sortRowList","sortedRows","groupedByParentRows","Map","body","footer","i","length","rowId","node","group","get","parent","set","position","push","sortedGroupedByParentRows","forEach","groupSortedRows","depth","map","row","id","insertRowListIntoSortedRows","startIndex","rowList","slice","treeSize","children","subTreeSize"],"sources":["/workspaces/Backwoodaroma/node_modules/@mui/x-data-grid-pro/utils/tree/sortRowTree.js"],"sourcesContent":["export const sortRowTree = params => {\n  const {\n    rowIds,\n    rowTree,\n    disableChildrenSorting,\n    sortRowList\n  } = params;\n  let sortedRows = []; // Group the rows by parent\n\n  const groupedByParentRows = new Map([[null, {\n    body: [],\n    footer: null\n  }]]);\n\n  for (let i = 0; i < rowIds.length; i += 1) {\n    const rowId = rowIds[i];\n    const node = rowTree[rowId];\n    let group = groupedByParentRows.get(node.parent);\n\n    if (!group) {\n      group = {\n        body: [],\n        footer: null\n      };\n      groupedByParentRows.set(node.parent, group);\n    }\n\n    if (node.position === 'footer') {\n      group.footer = node;\n    } else {\n      group.body.push(node);\n    }\n  } // Apply the sorting to each list of children\n\n\n  const sortedGroupedByParentRows = new Map();\n  groupedByParentRows.forEach((group, parent) => {\n    if (group.body.length === 0) {\n      sortedGroupedByParentRows.set(parent, []);\n    } else {\n      let groupSortedRows;\n      const depth = group.body[0].depth;\n\n      if (depth > 0 && disableChildrenSorting || !sortRowList) {\n        groupSortedRows = group.body.map(row => row.id);\n      } else {\n        groupSortedRows = sortRowList(group.body);\n      }\n\n      if (group.footer != null) {\n        groupSortedRows.push(group.footer.id);\n      }\n\n      sortedGroupedByParentRows.set(parent, groupSortedRows);\n    }\n  }); // Flatten the sorted lists to have children just after their parent\n\n  const insertRowListIntoSortedRows = (startIndex, rowList) => {\n    sortedRows = [...sortedRows.slice(0, startIndex), ...rowList, ...sortedRows.slice(startIndex)];\n    let treeSize = 0;\n    rowList.forEach(rowId => {\n      treeSize += 1;\n      const children = sortedGroupedByParentRows.get(rowId);\n\n      if (children != null && children.length) {\n        const subTreeSize = insertRowListIntoSortedRows(startIndex + treeSize, children);\n        treeSize += subTreeSize;\n      }\n    });\n    return treeSize;\n  };\n\n  insertRowListIntoSortedRows(0, sortedGroupedByParentRows.get(null));\n  return sortedRows;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}