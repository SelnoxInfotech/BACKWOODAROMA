{"ast":null,"code":"import _defineProperty from \"/workspaces/Backwoodaroma/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _toConsumableArray from \"/workspaces/Backwoodaroma/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/workspaces/Backwoodaroma/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport MuiDivider from '@mui/material/Divider';\nimport { useGridSelector, gridVisibleColumnDefinitionsSelector, gridColumnsTotalWidthSelector, gridColumnPositionsSelector, gridVisibleColumnFieldsSelector, gridClasses, useGridApiMethod, useGridApiEventHandler, gridColumnFieldsSelector } from '@mui/x-data-grid';\nimport { useGridRegisterPipeProcessor } from '@mui/x-data-grid/internals';\nimport { GridColumnPinningMenuItems } from '../../../components/GridColumnPinningMenuItems';\nimport { GridPinnedPosition } from './gridColumnPinningInterface';\nimport { gridPinnedColumnsSelector } from './gridColumnPinningSelector';\nimport { filterColumns } from '../../../components/DataGridProVirtualScroller';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nvar Divider = function Divider() {\n  return /*#__PURE__*/_jsx(MuiDivider, {\n    onClick: function onClick(event) {\n      return event.stopPropagation();\n    }\n  });\n};\nexport var columnPinningStateInitializer = function columnPinningStateInitializer(state, props, apiRef) {\n  var _props$initialState;\n  apiRef.current.unstable_caches.columnPinning = {\n    orderedFieldsBeforePinningColumns: null\n  };\n  var model;\n  if (props.disableColumnPinning) {\n    model = {};\n  } else if (props.pinnedColumns) {\n    model = props.pinnedColumns;\n  } else if ((_props$initialState = props.initialState) != null && _props$initialState.pinnedColumns) {\n    var _props$initialState2;\n    model = (_props$initialState2 = props.initialState) == null ? void 0 : _props$initialState2.pinnedColumns;\n  } else {\n    model = {};\n  }\n  return _extends({}, state, {\n    pinnedColumns: model\n  });\n};\nvar mergeStateWithPinnedColumns = function mergeStateWithPinnedColumns(pinnedColumns) {\n  return function (state) {\n    return _extends({}, state, {\n      pinnedColumns: pinnedColumns\n    });\n  };\n};\nexport var useGridColumnPinning = function useGridColumnPinning(apiRef, props) {\n  var _props$initialState4;\n  var pinnedColumns = useGridSelector(apiRef, gridPinnedColumnsSelector); // Each visible row (not to be confused with a filter result) is composed of a central .MuiDataGrid-row element\n  // and up to two additional .MuiDataGrid-row's, one for the columns pinned to the left and another\n  // for those on the right side. When hovering any of these elements, the :hover styles are applied only to\n  // the row element that was actually hovered, not its additional siblings. To make it look like a contiguous row,\n  // this method adds/removes the .Mui-hovered class to all of the row elements inside one visible row.\n\n  var updateHoveredClassOnSiblingRows = React.useCallback(function (event) {\n    var _pinnedColumns$left$l, _pinnedColumns$left, _pinnedColumns$right$, _pinnedColumns$right;\n    if (props.disableColumnPinning) {\n      return;\n    }\n    if (!Array.isArray(pinnedColumns.left) && !Array.isArray(pinnedColumns.right)) {\n      return;\n    }\n    var nbLeftPinnedColumns = (_pinnedColumns$left$l = (_pinnedColumns$left = pinnedColumns.left) == null ? void 0 : _pinnedColumns$left.length) != null ? _pinnedColumns$left$l : 0;\n    var nbRightPinnedColumns = (_pinnedColumns$right$ = (_pinnedColumns$right = pinnedColumns.right) == null ? void 0 : _pinnedColumns$right.length) != null ? _pinnedColumns$right$ : 0;\n    if (nbLeftPinnedColumns + nbRightPinnedColumns === 0) {\n      return;\n    }\n    var index = event.currentTarget.dataset.rowindex;\n    var rowElements = apiRef.current.windowRef.current.querySelectorAll(\".\".concat(gridClasses.row, \"[data-rowindex=\\\"\").concat(index, \"\\\"]\"));\n    rowElements.forEach(function (row) {\n      // Ignore rows from other grid inside the hovered row\n      if (row.closest(\".\".concat(gridClasses.virtualScroller)) === apiRef.current.windowRef.current) {\n        if (event.type === 'mouseenter') {\n          row.classList.add('Mui-hovered');\n        } else {\n          row.classList.remove('Mui-hovered');\n        }\n      }\n    });\n  }, [apiRef, pinnedColumns.left, pinnedColumns.right, props.disableColumnPinning]);\n  var handleMouseEnter = React.useCallback(function (params, event) {\n    updateHoveredClassOnSiblingRows(event);\n  }, [updateHoveredClassOnSiblingRows]);\n  var handleMouseLeave = React.useCallback(function (params, event) {\n    updateHoveredClassOnSiblingRows(event);\n  }, [updateHoveredClassOnSiblingRows]);\n  useGridApiEventHandler(apiRef, 'rowMouseEnter', handleMouseEnter);\n  useGridApiEventHandler(apiRef, 'rowMouseLeave', handleMouseLeave);\n  /**\n   * PRE-PROCESSING\n   */\n\n  var calculateScrollLeft = React.useCallback(function (initialValue, params) {\n    if (props.disableColumnPinning) {\n      return initialValue;\n    }\n    var visibleColumnFields = gridVisibleColumnFieldsSelector(apiRef);\n    var _filterColumns = filterColumns(pinnedColumns, visibleColumnFields),\n      _filterColumns2 = _slicedToArray(_filterColumns, 2),\n      leftPinnedColumns = _filterColumns2[0],\n      rightPinnedColumns = _filterColumns2[1];\n    if (!params.colIndex || leftPinnedColumns.length === 0 && rightPinnedColumns.length === 0) {\n      return initialValue;\n    }\n    var visibleColumns = gridVisibleColumnDefinitionsSelector(apiRef);\n    var columnsTotalWidth = gridColumnsTotalWidthSelector(apiRef);\n    var columnPositions = gridColumnPositionsSelector(apiRef);\n    var clientWidth = apiRef.current.windowRef.current.clientWidth;\n    var scrollLeft = apiRef.current.windowRef.current.scrollLeft;\n    var offsetWidth = visibleColumns[params.colIndex].computedWidth;\n    var offsetLeft = columnPositions[params.colIndex];\n    var leftPinnedColumnsWidth = columnPositions[leftPinnedColumns.length];\n    var rightPinnedColumnsWidth = columnsTotalWidth - columnPositions[columnPositions.length - rightPinnedColumns.length];\n    var elementBottom = offsetLeft + offsetWidth;\n    if (elementBottom - (clientWidth - rightPinnedColumnsWidth) > scrollLeft) {\n      var left = elementBottom - (clientWidth - rightPinnedColumnsWidth);\n      return _extends({}, initialValue, {\n        left: left\n      });\n    }\n    if (offsetLeft < scrollLeft + leftPinnedColumnsWidth) {\n      var _left = offsetLeft - leftPinnedColumnsWidth;\n      return _extends({}, initialValue, {\n        left: _left\n      });\n    }\n    return initialValue;\n  }, [apiRef, pinnedColumns, props.disableColumnPinning]);\n  var addColumnMenuButtons = React.useCallback(function (initialValue, column) {\n    if (props.disableColumnPinning) {\n      return initialValue;\n    }\n    if (column.pinnable === false) {\n      return initialValue;\n    }\n    return [].concat(_toConsumableArray(initialValue), [/*#__PURE__*/_jsx(Divider, {}), /*#__PURE__*/_jsx(GridColumnPinningMenuItems, {})]);\n  }, [props.disableColumnPinning]);\n  var checkIfCanBeReordered = React.useCallback(function (initialValue, _ref) {\n    var targetIndex = _ref.targetIndex;\n    var visibleColumnFields = gridVisibleColumnFieldsSelector(apiRef);\n    var _filterColumns3 = filterColumns(pinnedColumns, visibleColumnFields),\n      _filterColumns4 = _slicedToArray(_filterColumns3, 2),\n      leftPinnedColumns = _filterColumns4[0],\n      rightPinnedColumns = _filterColumns4[1];\n    if (leftPinnedColumns.length === 0 && rightPinnedColumns.length === 0) {\n      return initialValue;\n    }\n    if (leftPinnedColumns.length > 0 && targetIndex < leftPinnedColumns.length) {\n      return false;\n    }\n    if (rightPinnedColumns.length > 0) {\n      var visibleColumns = gridVisibleColumnDefinitionsSelector(apiRef);\n      var firstRightPinnedColumnIndex = visibleColumns.length - rightPinnedColumns.length;\n      return targetIndex >= firstRightPinnedColumnIndex ? false : initialValue;\n    }\n    return initialValue;\n  }, [apiRef, pinnedColumns]);\n  var stateExportPreProcessing = React.useCallback(function (prevState, context) {\n    var _props$initialState3, _pinnedColumnsToExpor, _pinnedColumnsToExpor2;\n    var pinnedColumnsToExport = gridPinnedColumnsSelector(apiRef.current.state);\n    var shouldExportPinnedColumns =\n    // Always export if the `exportOnlyDirtyModels` property is activated\n    !context.exportOnlyDirtyModels ||\n    // Always export if the model is controlled\n    props.pinnedColumns != null ||\n    // Always export if the model has been initialized\n    ((_props$initialState3 = props.initialState) == null ? void 0 : _props$initialState3.pinnedColumns) != null ||\n    // Export if the model is not empty\n    ((_pinnedColumnsToExpor = pinnedColumnsToExport.left) != null ? _pinnedColumnsToExpor : []).length > 0 || ((_pinnedColumnsToExpor2 = pinnedColumnsToExport.right) != null ? _pinnedColumnsToExpor2 : []).length > 0;\n    if (!shouldExportPinnedColumns) {\n      return prevState;\n    }\n    return _extends({}, prevState, {\n      pinnedColumns: pinnedColumnsToExport\n    });\n  }, [apiRef, props.pinnedColumns, (_props$initialState4 = props.initialState) == null ? void 0 : _props$initialState4.pinnedColumns]);\n  var stateRestorePreProcessing = React.useCallback(function (params, context) {\n    var newPinnedColumns = context.stateToRestore.pinnedColumns;\n    if (newPinnedColumns != null) {\n      apiRef.current.setState(mergeStateWithPinnedColumns(newPinnedColumns));\n    }\n    return params;\n  }, [apiRef]);\n  useGridRegisterPipeProcessor(apiRef, 'scrollToIndexes', calculateScrollLeft);\n  useGridRegisterPipeProcessor(apiRef, 'columnMenu', addColumnMenuButtons);\n  useGridRegisterPipeProcessor(apiRef, 'canBeReordered', checkIfCanBeReordered);\n  useGridRegisterPipeProcessor(apiRef, 'exportState', stateExportPreProcessing);\n  useGridRegisterPipeProcessor(apiRef, 'restoreState', stateRestorePreProcessing);\n  apiRef.current.unstable_registerControlState({\n    stateId: 'pinnedColumns',\n    propModel: props.pinnedColumns,\n    propOnChange: props.onPinnedColumnsChange,\n    stateSelector: gridPinnedColumnsSelector,\n    changeEvent: 'pinnedColumnsChange'\n  });\n  var checkIfEnabled = React.useCallback(function (methodName) {\n    if (props.disableColumnPinning) {\n      throw new Error(\"MUI: You cannot call `apiRef.current.\".concat(methodName, \"` when `disableColumnPinning` is true.\"));\n    }\n  }, [props.disableColumnPinning]);\n  var pinColumn = React.useCallback(function (field, side) {\n    var _newPinnedColumns;\n    checkIfEnabled('pinColumn');\n    if (apiRef.current.isColumnPinned(field) === side) {\n      return;\n    }\n    var otherSide = side === GridPinnedPosition.right ? GridPinnedPosition.left : GridPinnedPosition.right;\n    var newPinnedColumns = (_newPinnedColumns = {}, _defineProperty(_newPinnedColumns, side, [].concat(_toConsumableArray(pinnedColumns[side] || []), [field])), _defineProperty(_newPinnedColumns, otherSide, (pinnedColumns[otherSide] || []).filter(function (column) {\n      return column !== field;\n    })), _newPinnedColumns);\n    apiRef.current.setPinnedColumns(newPinnedColumns);\n  }, [apiRef, checkIfEnabled, pinnedColumns]);\n  var unpinColumn = React.useCallback(function (field) {\n    checkIfEnabled('unpinColumn');\n    apiRef.current.setPinnedColumns({\n      left: (pinnedColumns.left || []).filter(function (column) {\n        return column !== field;\n      }),\n      right: (pinnedColumns.right || []).filter(function (column) {\n        return column !== field;\n      })\n    });\n  }, [apiRef, checkIfEnabled, pinnedColumns.left, pinnedColumns.right]);\n  var getPinnedColumns = React.useCallback(function () {\n    checkIfEnabled('getPinnedColumns');\n    return gridPinnedColumnsSelector(apiRef.current.state);\n  }, [apiRef, checkIfEnabled]);\n  var setPinnedColumns = React.useCallback(function (newPinnedColumns) {\n    checkIfEnabled('setPinnedColumns');\n    apiRef.current.setState(mergeStateWithPinnedColumns(newPinnedColumns));\n    apiRef.current.forceUpdate();\n  }, [apiRef, checkIfEnabled]);\n  var isColumnPinned = React.useCallback(function (field) {\n    checkIfEnabled('isColumnPinned');\n    var leftPinnedColumns = pinnedColumns.left || [];\n    if (leftPinnedColumns.includes(field)) {\n      return GridPinnedPosition.left;\n    }\n    var rightPinnedColumns = pinnedColumns.right || [];\n    if (rightPinnedColumns.includes(field)) {\n      return GridPinnedPosition.right;\n    }\n    return false;\n  }, [pinnedColumns.left, pinnedColumns.right, checkIfEnabled]);\n  var columnPinningApi = {\n    pinColumn: pinColumn,\n    unpinColumn: unpinColumn,\n    getPinnedColumns: getPinnedColumns,\n    setPinnedColumns: setPinnedColumns,\n    isColumnPinned: isColumnPinned\n  };\n  useGridApiMethod(apiRef, columnPinningApi, 'columnPinningApi');\n  var handleColumnOrderChange = React.useCallback(function (params) {\n    if (!apiRef.current.unstable_caches.columnPinning.orderedFieldsBeforePinningColumns) {\n      return;\n    }\n    var field = params.field,\n      targetIndex = params.targetIndex,\n      oldIndex = params.oldIndex;\n    var delta = targetIndex > oldIndex ? 1 : -1;\n    var latestColumnFields = gridColumnFieldsSelector(apiRef);\n    /**\n     * When a column X is reordered to somewhere else, the position where this column X is dropped\n     * on must be moved to left or right to make room for it. The ^^^ below represents the column\n     * which gave space to receive X.\n     *\n     * | X | B | C | D | -> | B | C | D | X | (e.g. X moved to after D, so delta=1)\n     *              ^^^              ^^^\n     *\n     * | A | B | C | X | -> | X | A | B | C | (e.g. X moved before A, so delta=-1)\n     *  ^^^                      ^^^\n     *\n     * If column P is pinned, it will not move to provide space. However, it will jump to the next\n     * non-pinned column.\n     *\n     * | X | B | P | D | -> | B | D | P | X | (e.g. X moved to after D, with P pinned)\n     *              ^^^          ^^^\n     */\n\n    var siblingField = latestColumnFields[targetIndex - delta];\n    var newOrderedFieldsBeforePinningColumns = _toConsumableArray(apiRef.current.unstable_caches.columnPinning.orderedFieldsBeforePinningColumns); // The index to start swapping fields\n\n    var i = newOrderedFieldsBeforePinningColumns.findIndex(function (column) {\n      return column === field;\n    }); // The index of the field to swap with\n\n    var j = i + delta; // When to stop swapping fields.\n    // We stop one field before because the swap is done with i + 1 (if delta=1)\n\n    var stop = newOrderedFieldsBeforePinningColumns.findIndex(function (column) {\n      return column === siblingField;\n    });\n    while (delta > 0 ? i < stop : i > stop) {\n      // If the field to swap with is a pinned column, jump to the next\n      while (apiRef.current.isColumnPinned(newOrderedFieldsBeforePinningColumns[j])) {\n        j += delta;\n      }\n      var temp = newOrderedFieldsBeforePinningColumns[i];\n      newOrderedFieldsBeforePinningColumns[i] = newOrderedFieldsBeforePinningColumns[j];\n      newOrderedFieldsBeforePinningColumns[j] = temp;\n      i = j;\n      j = i + delta;\n    }\n    apiRef.current.unstable_caches.columnPinning.orderedFieldsBeforePinningColumns = newOrderedFieldsBeforePinningColumns;\n  }, [apiRef]);\n  useGridApiEventHandler(apiRef, 'columnOrderChange', handleColumnOrderChange);\n  React.useEffect(function () {\n    if (props.pinnedColumns) {\n      apiRef.current.setPinnedColumns(props.pinnedColumns);\n    }\n  }, [apiRef, props.pinnedColumns]);\n};","map":{"version":3,"names":["_extends","React","MuiDivider","useGridSelector","gridVisibleColumnDefinitionsSelector","gridColumnsTotalWidthSelector","gridColumnPositionsSelector","gridVisibleColumnFieldsSelector","gridClasses","useGridApiMethod","useGridApiEventHandler","gridColumnFieldsSelector","useGridRegisterPipeProcessor","GridColumnPinningMenuItems","GridPinnedPosition","gridPinnedColumnsSelector","filterColumns","jsx","_jsx","Divider","onClick","event","stopPropagation","columnPinningStateInitializer","state","props","apiRef","_props$initialState","current","unstable_caches","columnPinning","orderedFieldsBeforePinningColumns","model","disableColumnPinning","pinnedColumns","initialState","_props$initialState2","mergeStateWithPinnedColumns","useGridColumnPinning","_props$initialState4","updateHoveredClassOnSiblingRows","useCallback","_pinnedColumns$left$l","_pinnedColumns$left","_pinnedColumns$right$","_pinnedColumns$right","Array","isArray","left","right","nbLeftPinnedColumns","length","nbRightPinnedColumns","index","currentTarget","dataset","rowindex","rowElements","windowRef","querySelectorAll","row","forEach","closest","virtualScroller","type","classList","add","remove","handleMouseEnter","params","handleMouseLeave","calculateScrollLeft","initialValue","visibleColumnFields","leftPinnedColumns","rightPinnedColumns","colIndex","visibleColumns","columnsTotalWidth","columnPositions","clientWidth","scrollLeft","offsetWidth","computedWidth","offsetLeft","leftPinnedColumnsWidth","rightPinnedColumnsWidth","elementBottom","addColumnMenuButtons","column","pinnable","checkIfCanBeReordered","targetIndex","firstRightPinnedColumnIndex","stateExportPreProcessing","prevState","context","_props$initialState3","_pinnedColumnsToExpor","_pinnedColumnsToExpor2","pinnedColumnsToExport","shouldExportPinnedColumns","exportOnlyDirtyModels","stateRestorePreProcessing","newPinnedColumns","stateToRestore","setState","unstable_registerControlState","stateId","propModel","propOnChange","onPinnedColumnsChange","stateSelector","changeEvent","checkIfEnabled","methodName","Error","pinColumn","field","side","isColumnPinned","otherSide","filter","setPinnedColumns","unpinColumn","getPinnedColumns","forceUpdate","includes","columnPinningApi","handleColumnOrderChange","oldIndex","delta","latestColumnFields","siblingField","newOrderedFieldsBeforePinningColumns","i","findIndex","j","stop","temp","useEffect"],"sources":["/workspaces/Backwoodaroma/node_modules/@mui/x-data-grid-pro/hooks/features/columnPinning/useGridColumnPinning.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport MuiDivider from '@mui/material/Divider';\nimport { useGridSelector, gridVisibleColumnDefinitionsSelector, gridColumnsTotalWidthSelector, gridColumnPositionsSelector, gridVisibleColumnFieldsSelector, gridClasses, useGridApiMethod, useGridApiEventHandler, gridColumnFieldsSelector } from '@mui/x-data-grid';\nimport { useGridRegisterPipeProcessor } from '@mui/x-data-grid/internals';\nimport { GridColumnPinningMenuItems } from '../../../components/GridColumnPinningMenuItems';\nimport { GridPinnedPosition } from './gridColumnPinningInterface';\nimport { gridPinnedColumnsSelector } from './gridColumnPinningSelector';\nimport { filterColumns } from '../../../components/DataGridProVirtualScroller';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n\nconst Divider = () => /*#__PURE__*/_jsx(MuiDivider, {\n  onClick: event => event.stopPropagation()\n});\n\nexport const columnPinningStateInitializer = (state, props, apiRef) => {\n  var _props$initialState;\n\n  apiRef.current.unstable_caches.columnPinning = {\n    orderedFieldsBeforePinningColumns: null\n  };\n  let model;\n\n  if (props.disableColumnPinning) {\n    model = {};\n  } else if (props.pinnedColumns) {\n    model = props.pinnedColumns;\n  } else if ((_props$initialState = props.initialState) != null && _props$initialState.pinnedColumns) {\n    var _props$initialState2;\n\n    model = (_props$initialState2 = props.initialState) == null ? void 0 : _props$initialState2.pinnedColumns;\n  } else {\n    model = {};\n  }\n\n  return _extends({}, state, {\n    pinnedColumns: model\n  });\n};\n\nconst mergeStateWithPinnedColumns = pinnedColumns => state => _extends({}, state, {\n  pinnedColumns\n});\n\nexport const useGridColumnPinning = (apiRef, props) => {\n  var _props$initialState4;\n\n  const pinnedColumns = useGridSelector(apiRef, gridPinnedColumnsSelector); // Each visible row (not to be confused with a filter result) is composed of a central .MuiDataGrid-row element\n  // and up to two additional .MuiDataGrid-row's, one for the columns pinned to the left and another\n  // for those on the right side. When hovering any of these elements, the :hover styles are applied only to\n  // the row element that was actually hovered, not its additional siblings. To make it look like a contiguous row,\n  // this method adds/removes the .Mui-hovered class to all of the row elements inside one visible row.\n\n  const updateHoveredClassOnSiblingRows = React.useCallback(event => {\n    var _pinnedColumns$left$l, _pinnedColumns$left, _pinnedColumns$right$, _pinnedColumns$right;\n\n    if (props.disableColumnPinning) {\n      return;\n    }\n\n    if (!Array.isArray(pinnedColumns.left) && !Array.isArray(pinnedColumns.right)) {\n      return;\n    }\n\n    const nbLeftPinnedColumns = (_pinnedColumns$left$l = (_pinnedColumns$left = pinnedColumns.left) == null ? void 0 : _pinnedColumns$left.length) != null ? _pinnedColumns$left$l : 0;\n    const nbRightPinnedColumns = (_pinnedColumns$right$ = (_pinnedColumns$right = pinnedColumns.right) == null ? void 0 : _pinnedColumns$right.length) != null ? _pinnedColumns$right$ : 0;\n\n    if (nbLeftPinnedColumns + nbRightPinnedColumns === 0) {\n      return;\n    }\n\n    const index = event.currentTarget.dataset.rowindex;\n    const rowElements = apiRef.current.windowRef.current.querySelectorAll(`.${gridClasses.row}[data-rowindex=\"${index}\"]`);\n    rowElements.forEach(row => {\n      // Ignore rows from other grid inside the hovered row\n      if (row.closest(`.${gridClasses.virtualScroller}`) === apiRef.current.windowRef.current) {\n        if (event.type === 'mouseenter') {\n          row.classList.add('Mui-hovered');\n        } else {\n          row.classList.remove('Mui-hovered');\n        }\n      }\n    });\n  }, [apiRef, pinnedColumns.left, pinnedColumns.right, props.disableColumnPinning]);\n  const handleMouseEnter = React.useCallback((params, event) => {\n    updateHoveredClassOnSiblingRows(event);\n  }, [updateHoveredClassOnSiblingRows]);\n  const handleMouseLeave = React.useCallback((params, event) => {\n    updateHoveredClassOnSiblingRows(event);\n  }, [updateHoveredClassOnSiblingRows]);\n  useGridApiEventHandler(apiRef, 'rowMouseEnter', handleMouseEnter);\n  useGridApiEventHandler(apiRef, 'rowMouseLeave', handleMouseLeave);\n  /**\n   * PRE-PROCESSING\n   */\n\n  const calculateScrollLeft = React.useCallback((initialValue, params) => {\n    if (props.disableColumnPinning) {\n      return initialValue;\n    }\n\n    const visibleColumnFields = gridVisibleColumnFieldsSelector(apiRef);\n    const [leftPinnedColumns, rightPinnedColumns] = filterColumns(pinnedColumns, visibleColumnFields);\n\n    if (!params.colIndex || leftPinnedColumns.length === 0 && rightPinnedColumns.length === 0) {\n      return initialValue;\n    }\n\n    const visibleColumns = gridVisibleColumnDefinitionsSelector(apiRef);\n    const columnsTotalWidth = gridColumnsTotalWidthSelector(apiRef);\n    const columnPositions = gridColumnPositionsSelector(apiRef);\n    const clientWidth = apiRef.current.windowRef.current.clientWidth;\n    const scrollLeft = apiRef.current.windowRef.current.scrollLeft;\n    const offsetWidth = visibleColumns[params.colIndex].computedWidth;\n    const offsetLeft = columnPositions[params.colIndex];\n    const leftPinnedColumnsWidth = columnPositions[leftPinnedColumns.length];\n    const rightPinnedColumnsWidth = columnsTotalWidth - columnPositions[columnPositions.length - rightPinnedColumns.length];\n    const elementBottom = offsetLeft + offsetWidth;\n\n    if (elementBottom - (clientWidth - rightPinnedColumnsWidth) > scrollLeft) {\n      const left = elementBottom - (clientWidth - rightPinnedColumnsWidth);\n      return _extends({}, initialValue, {\n        left\n      });\n    }\n\n    if (offsetLeft < scrollLeft + leftPinnedColumnsWidth) {\n      const left = offsetLeft - leftPinnedColumnsWidth;\n      return _extends({}, initialValue, {\n        left\n      });\n    }\n\n    return initialValue;\n  }, [apiRef, pinnedColumns, props.disableColumnPinning]);\n  const addColumnMenuButtons = React.useCallback((initialValue, column) => {\n    if (props.disableColumnPinning) {\n      return initialValue;\n    }\n\n    if (column.pinnable === false) {\n      return initialValue;\n    }\n\n    return [...initialValue, /*#__PURE__*/_jsx(Divider, {}), /*#__PURE__*/_jsx(GridColumnPinningMenuItems, {})];\n  }, [props.disableColumnPinning]);\n  const checkIfCanBeReordered = React.useCallback((initialValue, {\n    targetIndex\n  }) => {\n    const visibleColumnFields = gridVisibleColumnFieldsSelector(apiRef);\n    const [leftPinnedColumns, rightPinnedColumns] = filterColumns(pinnedColumns, visibleColumnFields);\n\n    if (leftPinnedColumns.length === 0 && rightPinnedColumns.length === 0) {\n      return initialValue;\n    }\n\n    if (leftPinnedColumns.length > 0 && targetIndex < leftPinnedColumns.length) {\n      return false;\n    }\n\n    if (rightPinnedColumns.length > 0) {\n      const visibleColumns = gridVisibleColumnDefinitionsSelector(apiRef);\n      const firstRightPinnedColumnIndex = visibleColumns.length - rightPinnedColumns.length;\n      return targetIndex >= firstRightPinnedColumnIndex ? false : initialValue;\n    }\n\n    return initialValue;\n  }, [apiRef, pinnedColumns]);\n  const stateExportPreProcessing = React.useCallback((prevState, context) => {\n    var _props$initialState3, _pinnedColumnsToExpor, _pinnedColumnsToExpor2;\n\n    const pinnedColumnsToExport = gridPinnedColumnsSelector(apiRef.current.state);\n    const shouldExportPinnedColumns = // Always export if the `exportOnlyDirtyModels` property is activated\n    !context.exportOnlyDirtyModels || // Always export if the model is controlled\n    props.pinnedColumns != null || // Always export if the model has been initialized\n    ((_props$initialState3 = props.initialState) == null ? void 0 : _props$initialState3.pinnedColumns) != null || // Export if the model is not empty\n    ((_pinnedColumnsToExpor = pinnedColumnsToExport.left) != null ? _pinnedColumnsToExpor : []).length > 0 || ((_pinnedColumnsToExpor2 = pinnedColumnsToExport.right) != null ? _pinnedColumnsToExpor2 : []).length > 0;\n\n    if (!shouldExportPinnedColumns) {\n      return prevState;\n    }\n\n    return _extends({}, prevState, {\n      pinnedColumns: pinnedColumnsToExport\n    });\n  }, [apiRef, props.pinnedColumns, (_props$initialState4 = props.initialState) == null ? void 0 : _props$initialState4.pinnedColumns]);\n  const stateRestorePreProcessing = React.useCallback((params, context) => {\n    const newPinnedColumns = context.stateToRestore.pinnedColumns;\n\n    if (newPinnedColumns != null) {\n      apiRef.current.setState(mergeStateWithPinnedColumns(newPinnedColumns));\n    }\n\n    return params;\n  }, [apiRef]);\n  useGridRegisterPipeProcessor(apiRef, 'scrollToIndexes', calculateScrollLeft);\n  useGridRegisterPipeProcessor(apiRef, 'columnMenu', addColumnMenuButtons);\n  useGridRegisterPipeProcessor(apiRef, 'canBeReordered', checkIfCanBeReordered);\n  useGridRegisterPipeProcessor(apiRef, 'exportState', stateExportPreProcessing);\n  useGridRegisterPipeProcessor(apiRef, 'restoreState', stateRestorePreProcessing);\n  apiRef.current.unstable_registerControlState({\n    stateId: 'pinnedColumns',\n    propModel: props.pinnedColumns,\n    propOnChange: props.onPinnedColumnsChange,\n    stateSelector: gridPinnedColumnsSelector,\n    changeEvent: 'pinnedColumnsChange'\n  });\n  const checkIfEnabled = React.useCallback(methodName => {\n    if (props.disableColumnPinning) {\n      throw new Error(`MUI: You cannot call \\`apiRef.current.${methodName}\\` when \\`disableColumnPinning\\` is true.`);\n    }\n  }, [props.disableColumnPinning]);\n  const pinColumn = React.useCallback((field, side) => {\n    checkIfEnabled('pinColumn');\n\n    if (apiRef.current.isColumnPinned(field) === side) {\n      return;\n    }\n\n    const otherSide = side === GridPinnedPosition.right ? GridPinnedPosition.left : GridPinnedPosition.right;\n    const newPinnedColumns = {\n      [side]: [...(pinnedColumns[side] || []), field],\n      [otherSide]: (pinnedColumns[otherSide] || []).filter(column => column !== field)\n    };\n    apiRef.current.setPinnedColumns(newPinnedColumns);\n  }, [apiRef, checkIfEnabled, pinnedColumns]);\n  const unpinColumn = React.useCallback(field => {\n    checkIfEnabled('unpinColumn');\n    apiRef.current.setPinnedColumns({\n      left: (pinnedColumns.left || []).filter(column => column !== field),\n      right: (pinnedColumns.right || []).filter(column => column !== field)\n    });\n  }, [apiRef, checkIfEnabled, pinnedColumns.left, pinnedColumns.right]);\n  const getPinnedColumns = React.useCallback(() => {\n    checkIfEnabled('getPinnedColumns');\n    return gridPinnedColumnsSelector(apiRef.current.state);\n  }, [apiRef, checkIfEnabled]);\n  const setPinnedColumns = React.useCallback(newPinnedColumns => {\n    checkIfEnabled('setPinnedColumns');\n    apiRef.current.setState(mergeStateWithPinnedColumns(newPinnedColumns));\n    apiRef.current.forceUpdate();\n  }, [apiRef, checkIfEnabled]);\n  const isColumnPinned = React.useCallback(field => {\n    checkIfEnabled('isColumnPinned');\n    const leftPinnedColumns = pinnedColumns.left || [];\n\n    if (leftPinnedColumns.includes(field)) {\n      return GridPinnedPosition.left;\n    }\n\n    const rightPinnedColumns = pinnedColumns.right || [];\n\n    if (rightPinnedColumns.includes(field)) {\n      return GridPinnedPosition.right;\n    }\n\n    return false;\n  }, [pinnedColumns.left, pinnedColumns.right, checkIfEnabled]);\n  const columnPinningApi = {\n    pinColumn,\n    unpinColumn,\n    getPinnedColumns,\n    setPinnedColumns,\n    isColumnPinned\n  };\n  useGridApiMethod(apiRef, columnPinningApi, 'columnPinningApi');\n  const handleColumnOrderChange = React.useCallback(params => {\n    if (!apiRef.current.unstable_caches.columnPinning.orderedFieldsBeforePinningColumns) {\n      return;\n    }\n\n    const {\n      field,\n      targetIndex,\n      oldIndex\n    } = params;\n    const delta = targetIndex > oldIndex ? 1 : -1;\n    const latestColumnFields = gridColumnFieldsSelector(apiRef);\n    /**\n     * When a column X is reordered to somewhere else, the position where this column X is dropped\n     * on must be moved to left or right to make room for it. The ^^^ below represents the column\n     * which gave space to receive X.\n     *\n     * | X | B | C | D | -> | B | C | D | X | (e.g. X moved to after D, so delta=1)\n     *              ^^^              ^^^\n     *\n     * | A | B | C | X | -> | X | A | B | C | (e.g. X moved before A, so delta=-1)\n     *  ^^^                      ^^^\n     *\n     * If column P is pinned, it will not move to provide space. However, it will jump to the next\n     * non-pinned column.\n     *\n     * | X | B | P | D | -> | B | D | P | X | (e.g. X moved to after D, with P pinned)\n     *              ^^^          ^^^\n     */\n\n    const siblingField = latestColumnFields[targetIndex - delta];\n    const newOrderedFieldsBeforePinningColumns = [...apiRef.current.unstable_caches.columnPinning.orderedFieldsBeforePinningColumns]; // The index to start swapping fields\n\n    let i = newOrderedFieldsBeforePinningColumns.findIndex(column => column === field); // The index of the field to swap with\n\n    let j = i + delta; // When to stop swapping fields.\n    // We stop one field before because the swap is done with i + 1 (if delta=1)\n\n    const stop = newOrderedFieldsBeforePinningColumns.findIndex(column => column === siblingField);\n\n    while (delta > 0 ? i < stop : i > stop) {\n      // If the field to swap with is a pinned column, jump to the next\n      while (apiRef.current.isColumnPinned(newOrderedFieldsBeforePinningColumns[j])) {\n        j += delta;\n      }\n\n      const temp = newOrderedFieldsBeforePinningColumns[i];\n      newOrderedFieldsBeforePinningColumns[i] = newOrderedFieldsBeforePinningColumns[j];\n      newOrderedFieldsBeforePinningColumns[j] = temp;\n      i = j;\n      j = i + delta;\n    }\n\n    apiRef.current.unstable_caches.columnPinning.orderedFieldsBeforePinningColumns = newOrderedFieldsBeforePinningColumns;\n  }, [apiRef]);\n  useGridApiEventHandler(apiRef, 'columnOrderChange', handleColumnOrderChange);\n  React.useEffect(() => {\n    if (props.pinnedColumns) {\n      apiRef.current.setPinnedColumns(props.pinnedColumns);\n    }\n  }, [apiRef, props.pinnedColumns]);\n};"],"mappings":";;;AAAA,OAAOA,QAAQ,MAAM,oCAAoC;AACzD,OAAO,KAAKC,KAAK,MAAM,OAAO;AAC9B,OAAOC,UAAU,MAAM,uBAAuB;AAC9C,SAASC,eAAe,EAAEC,oCAAoC,EAAEC,6BAA6B,EAAEC,2BAA2B,EAAEC,+BAA+B,EAAEC,WAAW,EAAEC,gBAAgB,EAAEC,sBAAsB,EAAEC,wBAAwB,QAAQ,kBAAkB;AACtQ,SAASC,4BAA4B,QAAQ,4BAA4B;AACzE,SAASC,0BAA0B,QAAQ,gDAAgD;AAC3F,SAASC,kBAAkB,QAAQ,8BAA8B;AACjE,SAASC,yBAAyB,QAAQ,6BAA6B;AACvE,SAASC,aAAa,QAAQ,gDAAgD;AAC9E,SAASC,GAAG,IAAIC,IAAI,QAAQ,mBAAmB;AAE/C,IAAMC,OAAO,GAAG,SAAVA,OAAO;EAAA,OAAS,aAAaD,IAAI,CAAChB,UAAU,EAAE;IAClDkB,OAAO,EAAE,iBAAAC,KAAK;MAAA,OAAIA,KAAK,CAACC,eAAe,EAAE;IAAA;EAC3C,CAAC,CAAC;AAAA;AAEF,OAAO,IAAMC,6BAA6B,GAAG,SAAhCA,6BAA6B,CAAIC,KAAK,EAAEC,KAAK,EAAEC,MAAM,EAAK;EACrE,IAAIC,mBAAmB;EAEvBD,MAAM,CAACE,OAAO,CAACC,eAAe,CAACC,aAAa,GAAG;IAC7CC,iCAAiC,EAAE;EACrC,CAAC;EACD,IAAIC,KAAK;EAET,IAAIP,KAAK,CAACQ,oBAAoB,EAAE;IAC9BD,KAAK,GAAG,CAAC,CAAC;EACZ,CAAC,MAAM,IAAIP,KAAK,CAACS,aAAa,EAAE;IAC9BF,KAAK,GAAGP,KAAK,CAACS,aAAa;EAC7B,CAAC,MAAM,IAAI,CAACP,mBAAmB,GAAGF,KAAK,CAACU,YAAY,KAAK,IAAI,IAAIR,mBAAmB,CAACO,aAAa,EAAE;IAClG,IAAIE,oBAAoB;IAExBJ,KAAK,GAAG,CAACI,oBAAoB,GAAGX,KAAK,CAACU,YAAY,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGC,oBAAoB,CAACF,aAAa;EAC3G,CAAC,MAAM;IACLF,KAAK,GAAG,CAAC,CAAC;EACZ;EAEA,OAAOhC,QAAQ,CAAC,CAAC,CAAC,EAAEwB,KAAK,EAAE;IACzBU,aAAa,EAAEF;EACjB,CAAC,CAAC;AACJ,CAAC;AAED,IAAMK,2BAA2B,GAAG,SAA9BA,2BAA2B,CAAGH,aAAa;EAAA,OAAI,UAAAV,KAAK;IAAA,OAAIxB,QAAQ,CAAC,CAAC,CAAC,EAAEwB,KAAK,EAAE;MAChFU,aAAa,EAAbA;IACF,CAAC,CAAC;EAAA;AAAA;AAEF,OAAO,IAAMI,oBAAoB,GAAG,SAAvBA,oBAAoB,CAAIZ,MAAM,EAAED,KAAK,EAAK;EACrD,IAAIc,oBAAoB;EAExB,IAAML,aAAa,GAAG/B,eAAe,CAACuB,MAAM,EAAEX,yBAAyB,CAAC,CAAC,CAAC;EAC1E;EACA;EACA;EACA;;EAEA,IAAMyB,+BAA+B,GAAGvC,KAAK,CAACwC,WAAW,CAAC,UAAApB,KAAK,EAAI;IACjE,IAAIqB,qBAAqB,EAAEC,mBAAmB,EAAEC,qBAAqB,EAAEC,oBAAoB;IAE3F,IAAIpB,KAAK,CAACQ,oBAAoB,EAAE;MAC9B;IACF;IAEA,IAAI,CAACa,KAAK,CAACC,OAAO,CAACb,aAAa,CAACc,IAAI,CAAC,IAAI,CAACF,KAAK,CAACC,OAAO,CAACb,aAAa,CAACe,KAAK,CAAC,EAAE;MAC7E;IACF;IAEA,IAAMC,mBAAmB,GAAG,CAACR,qBAAqB,GAAG,CAACC,mBAAmB,GAAGT,aAAa,CAACc,IAAI,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGL,mBAAmB,CAACQ,MAAM,KAAK,IAAI,GAAGT,qBAAqB,GAAG,CAAC;IAClL,IAAMU,oBAAoB,GAAG,CAACR,qBAAqB,GAAG,CAACC,oBAAoB,GAAGX,aAAa,CAACe,KAAK,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGJ,oBAAoB,CAACM,MAAM,KAAK,IAAI,GAAGP,qBAAqB,GAAG,CAAC;IAEtL,IAAIM,mBAAmB,GAAGE,oBAAoB,KAAK,CAAC,EAAE;MACpD;IACF;IAEA,IAAMC,KAAK,GAAGhC,KAAK,CAACiC,aAAa,CAACC,OAAO,CAACC,QAAQ;IAClD,IAAMC,WAAW,GAAG/B,MAAM,CAACE,OAAO,CAAC8B,SAAS,CAAC9B,OAAO,CAAC+B,gBAAgB,YAAKnD,WAAW,CAACoD,GAAG,8BAAmBP,KAAK,SAAK;IACtHI,WAAW,CAACI,OAAO,CAAC,UAAAD,GAAG,EAAI;MACzB;MACA,IAAIA,GAAG,CAACE,OAAO,YAAKtD,WAAW,CAACuD,eAAe,EAAG,KAAKrC,MAAM,CAACE,OAAO,CAAC8B,SAAS,CAAC9B,OAAO,EAAE;QACvF,IAAIP,KAAK,CAAC2C,IAAI,KAAK,YAAY,EAAE;UAC/BJ,GAAG,CAACK,SAAS,CAACC,GAAG,CAAC,aAAa,CAAC;QAClC,CAAC,MAAM;UACLN,GAAG,CAACK,SAAS,CAACE,MAAM,CAAC,aAAa,CAAC;QACrC;MACF;IACF,CAAC,CAAC;EACJ,CAAC,EAAE,CAACzC,MAAM,EAAEQ,aAAa,CAACc,IAAI,EAAEd,aAAa,CAACe,KAAK,EAAExB,KAAK,CAACQ,oBAAoB,CAAC,CAAC;EACjF,IAAMmC,gBAAgB,GAAGnE,KAAK,CAACwC,WAAW,CAAC,UAAC4B,MAAM,EAAEhD,KAAK,EAAK;IAC5DmB,+BAA+B,CAACnB,KAAK,CAAC;EACxC,CAAC,EAAE,CAACmB,+BAA+B,CAAC,CAAC;EACrC,IAAM8B,gBAAgB,GAAGrE,KAAK,CAACwC,WAAW,CAAC,UAAC4B,MAAM,EAAEhD,KAAK,EAAK;IAC5DmB,+BAA+B,CAACnB,KAAK,CAAC;EACxC,CAAC,EAAE,CAACmB,+BAA+B,CAAC,CAAC;EACrC9B,sBAAsB,CAACgB,MAAM,EAAE,eAAe,EAAE0C,gBAAgB,CAAC;EACjE1D,sBAAsB,CAACgB,MAAM,EAAE,eAAe,EAAE4C,gBAAgB,CAAC;EACjE;AACF;AACA;;EAEE,IAAMC,mBAAmB,GAAGtE,KAAK,CAACwC,WAAW,CAAC,UAAC+B,YAAY,EAAEH,MAAM,EAAK;IACtE,IAAI5C,KAAK,CAACQ,oBAAoB,EAAE;MAC9B,OAAOuC,YAAY;IACrB;IAEA,IAAMC,mBAAmB,GAAGlE,+BAA+B,CAACmB,MAAM,CAAC;IACnE,qBAAgDV,aAAa,CAACkB,aAAa,EAAEuC,mBAAmB,CAAC;MAAA;MAA1FC,iBAAiB;MAAEC,kBAAkB;IAE5C,IAAI,CAACN,MAAM,CAACO,QAAQ,IAAIF,iBAAiB,CAACvB,MAAM,KAAK,CAAC,IAAIwB,kBAAkB,CAACxB,MAAM,KAAK,CAAC,EAAE;MACzF,OAAOqB,YAAY;IACrB;IAEA,IAAMK,cAAc,GAAGzE,oCAAoC,CAACsB,MAAM,CAAC;IACnE,IAAMoD,iBAAiB,GAAGzE,6BAA6B,CAACqB,MAAM,CAAC;IAC/D,IAAMqD,eAAe,GAAGzE,2BAA2B,CAACoB,MAAM,CAAC;IAC3D,IAAMsD,WAAW,GAAGtD,MAAM,CAACE,OAAO,CAAC8B,SAAS,CAAC9B,OAAO,CAACoD,WAAW;IAChE,IAAMC,UAAU,GAAGvD,MAAM,CAACE,OAAO,CAAC8B,SAAS,CAAC9B,OAAO,CAACqD,UAAU;IAC9D,IAAMC,WAAW,GAAGL,cAAc,CAACR,MAAM,CAACO,QAAQ,CAAC,CAACO,aAAa;IACjE,IAAMC,UAAU,GAAGL,eAAe,CAACV,MAAM,CAACO,QAAQ,CAAC;IACnD,IAAMS,sBAAsB,GAAGN,eAAe,CAACL,iBAAiB,CAACvB,MAAM,CAAC;IACxE,IAAMmC,uBAAuB,GAAGR,iBAAiB,GAAGC,eAAe,CAACA,eAAe,CAAC5B,MAAM,GAAGwB,kBAAkB,CAACxB,MAAM,CAAC;IACvH,IAAMoC,aAAa,GAAGH,UAAU,GAAGF,WAAW;IAE9C,IAAIK,aAAa,IAAIP,WAAW,GAAGM,uBAAuB,CAAC,GAAGL,UAAU,EAAE;MACxE,IAAMjC,IAAI,GAAGuC,aAAa,IAAIP,WAAW,GAAGM,uBAAuB,CAAC;MACpE,OAAOtF,QAAQ,CAAC,CAAC,CAAC,EAAEwE,YAAY,EAAE;QAChCxB,IAAI,EAAJA;MACF,CAAC,CAAC;IACJ;IAEA,IAAIoC,UAAU,GAAGH,UAAU,GAAGI,sBAAsB,EAAE;MACpD,IAAMrC,KAAI,GAAGoC,UAAU,GAAGC,sBAAsB;MAChD,OAAOrF,QAAQ,CAAC,CAAC,CAAC,EAAEwE,YAAY,EAAE;QAChCxB,IAAI,EAAJA;MACF,CAAC,CAAC;IACJ;IAEA,OAAOwB,YAAY;EACrB,CAAC,EAAE,CAAC9C,MAAM,EAAEQ,aAAa,EAAET,KAAK,CAACQ,oBAAoB,CAAC,CAAC;EACvD,IAAMuD,oBAAoB,GAAGvF,KAAK,CAACwC,WAAW,CAAC,UAAC+B,YAAY,EAAEiB,MAAM,EAAK;IACvE,IAAIhE,KAAK,CAACQ,oBAAoB,EAAE;MAC9B,OAAOuC,YAAY;IACrB;IAEA,IAAIiB,MAAM,CAACC,QAAQ,KAAK,KAAK,EAAE;MAC7B,OAAOlB,YAAY;IACrB;IAEA,oCAAWA,YAAY,IAAE,aAAatD,IAAI,CAACC,OAAO,EAAE,CAAC,CAAC,CAAC,EAAE,aAAaD,IAAI,CAACL,0BAA0B,EAAE,CAAC,CAAC,CAAC;EAC5G,CAAC,EAAE,CAACY,KAAK,CAACQ,oBAAoB,CAAC,CAAC;EAChC,IAAM0D,qBAAqB,GAAG1F,KAAK,CAACwC,WAAW,CAAC,UAAC+B,YAAY,QAEvD;IAAA,IADJoB,WAAW,QAAXA,WAAW;IAEX,IAAMnB,mBAAmB,GAAGlE,+BAA+B,CAACmB,MAAM,CAAC;IACnE,sBAAgDV,aAAa,CAACkB,aAAa,EAAEuC,mBAAmB,CAAC;MAAA;MAA1FC,iBAAiB;MAAEC,kBAAkB;IAE5C,IAAID,iBAAiB,CAACvB,MAAM,KAAK,CAAC,IAAIwB,kBAAkB,CAACxB,MAAM,KAAK,CAAC,EAAE;MACrE,OAAOqB,YAAY;IACrB;IAEA,IAAIE,iBAAiB,CAACvB,MAAM,GAAG,CAAC,IAAIyC,WAAW,GAAGlB,iBAAiB,CAACvB,MAAM,EAAE;MAC1E,OAAO,KAAK;IACd;IAEA,IAAIwB,kBAAkB,CAACxB,MAAM,GAAG,CAAC,EAAE;MACjC,IAAM0B,cAAc,GAAGzE,oCAAoC,CAACsB,MAAM,CAAC;MACnE,IAAMmE,2BAA2B,GAAGhB,cAAc,CAAC1B,MAAM,GAAGwB,kBAAkB,CAACxB,MAAM;MACrF,OAAOyC,WAAW,IAAIC,2BAA2B,GAAG,KAAK,GAAGrB,YAAY;IAC1E;IAEA,OAAOA,YAAY;EACrB,CAAC,EAAE,CAAC9C,MAAM,EAAEQ,aAAa,CAAC,CAAC;EAC3B,IAAM4D,wBAAwB,GAAG7F,KAAK,CAACwC,WAAW,CAAC,UAACsD,SAAS,EAAEC,OAAO,EAAK;IACzE,IAAIC,oBAAoB,EAAEC,qBAAqB,EAAEC,sBAAsB;IAEvE,IAAMC,qBAAqB,GAAGrF,yBAAyB,CAACW,MAAM,CAACE,OAAO,CAACJ,KAAK,CAAC;IAC7E,IAAM6E,yBAAyB;IAAG;IAClC,CAACL,OAAO,CAACM,qBAAqB;IAAI;IAClC7E,KAAK,CAACS,aAAa,IAAI,IAAI;IAAI;IAC/B,CAAC,CAAC+D,oBAAoB,GAAGxE,KAAK,CAACU,YAAY,KAAK,IAAI,GAAG,KAAK,CAAC,GAAG8D,oBAAoB,CAAC/D,aAAa,KAAK,IAAI;IAAI;IAC/G,CAAC,CAACgE,qBAAqB,GAAGE,qBAAqB,CAACpD,IAAI,KAAK,IAAI,GAAGkD,qBAAqB,GAAG,EAAE,EAAE/C,MAAM,GAAG,CAAC,IAAI,CAAC,CAACgD,sBAAsB,GAAGC,qBAAqB,CAACnD,KAAK,KAAK,IAAI,GAAGkD,sBAAsB,GAAG,EAAE,EAAEhD,MAAM,GAAG,CAAC;IAEnN,IAAI,CAACkD,yBAAyB,EAAE;MAC9B,OAAON,SAAS;IAClB;IAEA,OAAO/F,QAAQ,CAAC,CAAC,CAAC,EAAE+F,SAAS,EAAE;MAC7B7D,aAAa,EAAEkE;IACjB,CAAC,CAAC;EACJ,CAAC,EAAE,CAAC1E,MAAM,EAAED,KAAK,CAACS,aAAa,EAAE,CAACK,oBAAoB,GAAGd,KAAK,CAACU,YAAY,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGI,oBAAoB,CAACL,aAAa,CAAC,CAAC;EACpI,IAAMqE,yBAAyB,GAAGtG,KAAK,CAACwC,WAAW,CAAC,UAAC4B,MAAM,EAAE2B,OAAO,EAAK;IACvE,IAAMQ,gBAAgB,GAAGR,OAAO,CAACS,cAAc,CAACvE,aAAa;IAE7D,IAAIsE,gBAAgB,IAAI,IAAI,EAAE;MAC5B9E,MAAM,CAACE,OAAO,CAAC8E,QAAQ,CAACrE,2BAA2B,CAACmE,gBAAgB,CAAC,CAAC;IACxE;IAEA,OAAOnC,MAAM;EACf,CAAC,EAAE,CAAC3C,MAAM,CAAC,CAAC;EACZd,4BAA4B,CAACc,MAAM,EAAE,iBAAiB,EAAE6C,mBAAmB,CAAC;EAC5E3D,4BAA4B,CAACc,MAAM,EAAE,YAAY,EAAE8D,oBAAoB,CAAC;EACxE5E,4BAA4B,CAACc,MAAM,EAAE,gBAAgB,EAAEiE,qBAAqB,CAAC;EAC7E/E,4BAA4B,CAACc,MAAM,EAAE,aAAa,EAAEoE,wBAAwB,CAAC;EAC7ElF,4BAA4B,CAACc,MAAM,EAAE,cAAc,EAAE6E,yBAAyB,CAAC;EAC/E7E,MAAM,CAACE,OAAO,CAAC+E,6BAA6B,CAAC;IAC3CC,OAAO,EAAE,eAAe;IACxBC,SAAS,EAAEpF,KAAK,CAACS,aAAa;IAC9B4E,YAAY,EAAErF,KAAK,CAACsF,qBAAqB;IACzCC,aAAa,EAAEjG,yBAAyB;IACxCkG,WAAW,EAAE;EACf,CAAC,CAAC;EACF,IAAMC,cAAc,GAAGjH,KAAK,CAACwC,WAAW,CAAC,UAAA0E,UAAU,EAAI;IACrD,IAAI1F,KAAK,CAACQ,oBAAoB,EAAE;MAC9B,MAAM,IAAImF,KAAK,gDAA0CD,UAAU,4CAA4C;IACjH;EACF,CAAC,EAAE,CAAC1F,KAAK,CAACQ,oBAAoB,CAAC,CAAC;EAChC,IAAMoF,SAAS,GAAGpH,KAAK,CAACwC,WAAW,CAAC,UAAC6E,KAAK,EAAEC,IAAI,EAAK;IAAA;IACnDL,cAAc,CAAC,WAAW,CAAC;IAE3B,IAAIxF,MAAM,CAACE,OAAO,CAAC4F,cAAc,CAACF,KAAK,CAAC,KAAKC,IAAI,EAAE;MACjD;IACF;IAEA,IAAME,SAAS,GAAGF,IAAI,KAAKzG,kBAAkB,CAACmC,KAAK,GAAGnC,kBAAkB,CAACkC,IAAI,GAAGlC,kBAAkB,CAACmC,KAAK;IACxG,IAAMuD,gBAAgB,+DACnBe,IAAI,+BAAQrF,aAAa,CAACqF,IAAI,CAAC,IAAI,EAAE,IAAGD,KAAK,wCAC7CG,SAAS,EAAG,CAACvF,aAAa,CAACuF,SAAS,CAAC,IAAI,EAAE,EAAEC,MAAM,CAAC,UAAAjC,MAAM;MAAA,OAAIA,MAAM,KAAK6B,KAAK;IAAA,EAAC,qBACjF;IACD5F,MAAM,CAACE,OAAO,CAAC+F,gBAAgB,CAACnB,gBAAgB,CAAC;EACnD,CAAC,EAAE,CAAC9E,MAAM,EAAEwF,cAAc,EAAEhF,aAAa,CAAC,CAAC;EAC3C,IAAM0F,WAAW,GAAG3H,KAAK,CAACwC,WAAW,CAAC,UAAA6E,KAAK,EAAI;IAC7CJ,cAAc,CAAC,aAAa,CAAC;IAC7BxF,MAAM,CAACE,OAAO,CAAC+F,gBAAgB,CAAC;MAC9B3E,IAAI,EAAE,CAACd,aAAa,CAACc,IAAI,IAAI,EAAE,EAAE0E,MAAM,CAAC,UAAAjC,MAAM;QAAA,OAAIA,MAAM,KAAK6B,KAAK;MAAA,EAAC;MACnErE,KAAK,EAAE,CAACf,aAAa,CAACe,KAAK,IAAI,EAAE,EAAEyE,MAAM,CAAC,UAAAjC,MAAM;QAAA,OAAIA,MAAM,KAAK6B,KAAK;MAAA;IACtE,CAAC,CAAC;EACJ,CAAC,EAAE,CAAC5F,MAAM,EAAEwF,cAAc,EAAEhF,aAAa,CAACc,IAAI,EAAEd,aAAa,CAACe,KAAK,CAAC,CAAC;EACrE,IAAM4E,gBAAgB,GAAG5H,KAAK,CAACwC,WAAW,CAAC,YAAM;IAC/CyE,cAAc,CAAC,kBAAkB,CAAC;IAClC,OAAOnG,yBAAyB,CAACW,MAAM,CAACE,OAAO,CAACJ,KAAK,CAAC;EACxD,CAAC,EAAE,CAACE,MAAM,EAAEwF,cAAc,CAAC,CAAC;EAC5B,IAAMS,gBAAgB,GAAG1H,KAAK,CAACwC,WAAW,CAAC,UAAA+D,gBAAgB,EAAI;IAC7DU,cAAc,CAAC,kBAAkB,CAAC;IAClCxF,MAAM,CAACE,OAAO,CAAC8E,QAAQ,CAACrE,2BAA2B,CAACmE,gBAAgB,CAAC,CAAC;IACtE9E,MAAM,CAACE,OAAO,CAACkG,WAAW,EAAE;EAC9B,CAAC,EAAE,CAACpG,MAAM,EAAEwF,cAAc,CAAC,CAAC;EAC5B,IAAMM,cAAc,GAAGvH,KAAK,CAACwC,WAAW,CAAC,UAAA6E,KAAK,EAAI;IAChDJ,cAAc,CAAC,gBAAgB,CAAC;IAChC,IAAMxC,iBAAiB,GAAGxC,aAAa,CAACc,IAAI,IAAI,EAAE;IAElD,IAAI0B,iBAAiB,CAACqD,QAAQ,CAACT,KAAK,CAAC,EAAE;MACrC,OAAOxG,kBAAkB,CAACkC,IAAI;IAChC;IAEA,IAAM2B,kBAAkB,GAAGzC,aAAa,CAACe,KAAK,IAAI,EAAE;IAEpD,IAAI0B,kBAAkB,CAACoD,QAAQ,CAACT,KAAK,CAAC,EAAE;MACtC,OAAOxG,kBAAkB,CAACmC,KAAK;IACjC;IAEA,OAAO,KAAK;EACd,CAAC,EAAE,CAACf,aAAa,CAACc,IAAI,EAAEd,aAAa,CAACe,KAAK,EAAEiE,cAAc,CAAC,CAAC;EAC7D,IAAMc,gBAAgB,GAAG;IACvBX,SAAS,EAATA,SAAS;IACTO,WAAW,EAAXA,WAAW;IACXC,gBAAgB,EAAhBA,gBAAgB;IAChBF,gBAAgB,EAAhBA,gBAAgB;IAChBH,cAAc,EAAdA;EACF,CAAC;EACD/G,gBAAgB,CAACiB,MAAM,EAAEsG,gBAAgB,EAAE,kBAAkB,CAAC;EAC9D,IAAMC,uBAAuB,GAAGhI,KAAK,CAACwC,WAAW,CAAC,UAAA4B,MAAM,EAAI;IAC1D,IAAI,CAAC3C,MAAM,CAACE,OAAO,CAACC,eAAe,CAACC,aAAa,CAACC,iCAAiC,EAAE;MACnF;IACF;IAEA,IACEuF,KAAK,GAGHjD,MAAM,CAHRiD,KAAK;MACL1B,WAAW,GAETvB,MAAM,CAFRuB,WAAW;MACXsC,QAAQ,GACN7D,MAAM,CADR6D,QAAQ;IAEV,IAAMC,KAAK,GAAGvC,WAAW,GAAGsC,QAAQ,GAAG,CAAC,GAAG,CAAC,CAAC;IAC7C,IAAME,kBAAkB,GAAGzH,wBAAwB,CAACe,MAAM,CAAC;IAC3D;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IAEI,IAAM2G,YAAY,GAAGD,kBAAkB,CAACxC,WAAW,GAAGuC,KAAK,CAAC;IAC5D,IAAMG,oCAAoC,sBAAO5G,MAAM,CAACE,OAAO,CAACC,eAAe,CAACC,aAAa,CAACC,iCAAiC,CAAC,CAAC,CAAC;;IAElI,IAAIwG,CAAC,GAAGD,oCAAoC,CAACE,SAAS,CAAC,UAAA/C,MAAM;MAAA,OAAIA,MAAM,KAAK6B,KAAK;IAAA,EAAC,CAAC,CAAC;;IAEpF,IAAImB,CAAC,GAAGF,CAAC,GAAGJ,KAAK,CAAC,CAAC;IACnB;;IAEA,IAAMO,IAAI,GAAGJ,oCAAoC,CAACE,SAAS,CAAC,UAAA/C,MAAM;MAAA,OAAIA,MAAM,KAAK4C,YAAY;IAAA,EAAC;IAE9F,OAAOF,KAAK,GAAG,CAAC,GAAGI,CAAC,GAAGG,IAAI,GAAGH,CAAC,GAAGG,IAAI,EAAE;MACtC;MACA,OAAOhH,MAAM,CAACE,OAAO,CAAC4F,cAAc,CAACc,oCAAoC,CAACG,CAAC,CAAC,CAAC,EAAE;QAC7EA,CAAC,IAAIN,KAAK;MACZ;MAEA,IAAMQ,IAAI,GAAGL,oCAAoC,CAACC,CAAC,CAAC;MACpDD,oCAAoC,CAACC,CAAC,CAAC,GAAGD,oCAAoC,CAACG,CAAC,CAAC;MACjFH,oCAAoC,CAACG,CAAC,CAAC,GAAGE,IAAI;MAC9CJ,CAAC,GAAGE,CAAC;MACLA,CAAC,GAAGF,CAAC,GAAGJ,KAAK;IACf;IAEAzG,MAAM,CAACE,OAAO,CAACC,eAAe,CAACC,aAAa,CAACC,iCAAiC,GAAGuG,oCAAoC;EACvH,CAAC,EAAE,CAAC5G,MAAM,CAAC,CAAC;EACZhB,sBAAsB,CAACgB,MAAM,EAAE,mBAAmB,EAAEuG,uBAAuB,CAAC;EAC5EhI,KAAK,CAAC2I,SAAS,CAAC,YAAM;IACpB,IAAInH,KAAK,CAACS,aAAa,EAAE;MACvBR,MAAM,CAACE,OAAO,CAAC+F,gBAAgB,CAAClG,KAAK,CAACS,aAAa,CAAC;IACtD;EACF,CAAC,EAAE,CAACR,MAAM,EAAED,KAAK,CAACS,aAAa,CAAC,CAAC;AACnC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}