{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the /src directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\nimport { List, OrderedSet, Map } from 'immutable';\nimport { ContentState, CharacterMetadata, ContentBlock, Entity, BlockMapBuilder, genKey, SelectionState } from 'draft-js';\nimport getSafeBodyFromHTML from './util/parseHTML';\nimport rangeSort from './util/rangeSort';\nvar NBSP = '&nbsp;';\nvar SPACE = ' '; // Arbitrary max indent\n\nvar MAX_DEPTH = 4; // used for replacing characters in HTML\n\n/* eslint-disable no-control-regex */\n\nvar REGEX_CR = new RegExp('\\r', 'g');\nvar REGEX_LF = new RegExp('\\n', 'g');\nvar REGEX_NBSP = new RegExp(NBSP, 'g');\nvar REGEX_BLOCK_DELIMITER = new RegExp('\\r', 'g');\n/* eslint-enable no-control-regex */\n// Block tag flow is different because LIs do not have\n// a deterministic style ;_;\n\nvar blockTags = ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'li', 'blockquote', 'pre'];\nvar inlineTags = {\n  b: 'BOLD',\n  code: 'CODE',\n  del: 'STRIKETHROUGH',\n  em: 'ITALIC',\n  i: 'ITALIC',\n  s: 'STRIKETHROUGH',\n  strike: 'STRIKETHROUGH',\n  strong: 'BOLD',\n  u: 'UNDERLINE'\n};\nvar handleMiddleware = function handleMiddleware(maybeMiddleware, base) {\n  if (maybeMiddleware && maybeMiddleware.__isMiddleware === true) {\n    return maybeMiddleware(base);\n  }\n  return maybeMiddleware;\n};\nvar defaultHTMLToBlock = function defaultHTMLToBlock(nodeName, node, lastList) {\n  return undefined;\n};\nvar defaultHTMLToStyle = function defaultHTMLToStyle(nodeName, node, currentStyle) {\n  return currentStyle;\n};\nvar defaultHTMLToEntity = function defaultHTMLToEntity(nodeName, node) {\n  return undefined;\n};\nvar defaultTextToEntity = function defaultTextToEntity(text) {\n  return [];\n};\nvar nullthrows = function nullthrows(x) {\n  if (x != null) {\n    return x;\n  }\n  throw new Error('Got unexpected null or undefined');\n};\nvar sanitizeDraftText = function sanitizeDraftText(input) {\n  return input.replace(REGEX_BLOCK_DELIMITER, '');\n};\nfunction getEmptyChunk() {\n  return {\n    text: '',\n    inlines: [],\n    entities: [],\n    blocks: []\n  };\n}\nfunction getWhitespaceChunk(inEntity) {\n  var entities = new Array(1);\n  if (inEntity) {\n    entities[0] = inEntity;\n  }\n  return {\n    text: SPACE,\n    inlines: [OrderedSet()],\n    entities: entities,\n    blocks: []\n  };\n}\nfunction getSoftNewlineChunk(block, depth) {\n  var flat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Map();\n  if (flat === true) {\n    return {\n      text: '\\r',\n      inlines: [OrderedSet()],\n      entities: new Array(1),\n      blocks: [{\n        type: block,\n        data: data,\n        depth: Math.max(0, Math.min(MAX_DEPTH, depth))\n      }],\n      isNewline: true\n    };\n  }\n  return {\n    text: '\\n',\n    inlines: [OrderedSet()],\n    entities: new Array(1),\n    blocks: []\n  };\n}\nfunction getBlockDividerChunk(block, depth) {\n  var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Map();\n  return {\n    text: '\\r',\n    inlines: [OrderedSet()],\n    entities: new Array(1),\n    blocks: [{\n      type: block,\n      data: data,\n      depth: Math.max(0, Math.min(MAX_DEPTH, depth))\n    }]\n  };\n}\nfunction getBlockTypeForTag(tag, lastList) {\n  switch (tag) {\n    case 'h1':\n      return 'header-one';\n    case 'h2':\n      return 'header-two';\n    case 'h3':\n      return 'header-three';\n    case 'h4':\n      return 'header-four';\n    case 'h5':\n      return 'header-five';\n    case 'h6':\n      return 'header-six';\n    case 'li':\n      if (lastList === 'ol') {\n        return 'ordered-list-item';\n      }\n      return 'unordered-list-item';\n    case 'blockquote':\n      return 'blockquote';\n    case 'pre':\n      return 'code-block';\n    case 'div':\n    case 'p':\n      return 'unstyled';\n    default:\n      return null;\n  }\n}\nfunction baseCheckBlockType(nodeName, node, lastList) {\n  return getBlockTypeForTag(nodeName, lastList);\n}\nfunction processInlineTag(tag, node, currentStyle) {\n  var styleToCheck = inlineTags[tag];\n  if (styleToCheck) {\n    currentStyle = currentStyle.add(styleToCheck).toOrderedSet();\n  } else if (node instanceof HTMLElement) {\n    var htmlElement = node;\n    currentStyle = currentStyle.withMutations(function (style) {\n      if (htmlElement.style.fontWeight === 'bold') {\n        style.add('BOLD');\n      }\n      if (htmlElement.style.fontStyle === 'italic') {\n        style.add('ITALIC');\n      }\n      if (htmlElement.style.textDecoration === 'underline') {\n        style.add('UNDERLINE');\n      }\n      if (htmlElement.style.textDecoration === 'line-through') {\n        style.add('STRIKETHROUGH');\n      }\n    }).toOrderedSet();\n  }\n  return currentStyle;\n}\nfunction baseProcessInlineTag(tag, node) {\n  var inlineStyles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : OrderedSet();\n  return processInlineTag(tag, node, inlineStyles);\n}\nfunction joinChunks(A, B) {\n  var flat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // Sometimes two blocks will touch in the DOM and we need to strip the\n  // extra delimiter to preserve niceness.\n  var firstInB = B.text.slice(0, 1);\n  var lastInA = A.text.slice(-1);\n  var adjacentDividers = lastInA === '\\r' && firstInB === '\\r';\n  var isJoiningBlocks = A.text !== '\\r' && B.text !== '\\r'; // when joining two full blocks like this we want to pop one divider\n\n  var addingNewlineToEmptyBlock = A.text === '\\r' && !A.isNewline && B.isNewline; // when joining a newline to an empty block we want to remove the newline\n\n  if (adjacentDividers && (isJoiningBlocks || addingNewlineToEmptyBlock)) {\n    A.text = A.text.slice(0, -1);\n    A.inlines.pop();\n    A.entities.pop();\n    A.blocks.pop();\n  } // Kill whitespace after blocks if flat mode is on\n\n  if (A.text.slice(-1) === '\\r' && flat === true) {\n    if (B.text === SPACE || B.text === '\\n') {\n      return A;\n    } else if (firstInB === SPACE || firstInB === '\\n') {\n      B.text = B.text.slice(1);\n      B.inlines.shift();\n      B.entities.shift();\n    }\n  }\n  var isNewline = A.text.length === 0 && B.isNewline;\n  return {\n    text: A.text + B.text,\n    inlines: A.inlines.concat(B.inlines),\n    entities: A.entities.concat(B.entities),\n    blocks: A.blocks.concat(B.blocks),\n    isNewline: isNewline\n  };\n}\n/*\n * Check to see if we have anything like <p> <blockquote> <h1>... to create\n * block tags from. If we do, we can use those and ignore <div> tags. If we\n * don't, we can treat <div> tags as meaningful (unstyled) blocks.\n */\n\nfunction containsSemanticBlockMarkup(html) {\n  return blockTags.some(function (tag) {\n    return html.indexOf(\"<\".concat(tag)) !== -1;\n  });\n}\nfunction genFragment(node, inlineStyle, lastList, inBlock, fragmentBlockTags, depth, processCustomInlineStyles, checkEntityNode, checkEntityText, checkBlockType, createEntity, getEntity, mergeEntityData, replaceEntityData, options, inEntity) {\n  var nodeName = node.nodeName.toLowerCase();\n  var newBlock = false;\n  var nextBlockType = 'unstyled'; // Base Case\n\n  if (nodeName === '#text') {\n    var text = node.textContent;\n    if (text.trim() === '' && inBlock === null) {\n      return getEmptyChunk();\n    }\n    if (text.trim() === '' && inBlock !== 'code-block') {\n      return getWhitespaceChunk(inEntity);\n    }\n    if (inBlock !== 'code-block') {\n      // Can't use empty string because MSWord\n      text = text.replace(REGEX_LF, SPACE);\n    }\n    var entities = Array(text.length).fill(inEntity);\n    var offsetChange = 0;\n    var textEntities = checkEntityText(text, createEntity, getEntity, mergeEntityData, replaceEntityData).sort(rangeSort);\n    textEntities.forEach(function (_ref) {\n      var entity = _ref.entity,\n        offset = _ref.offset,\n        length = _ref.length,\n        result = _ref.result;\n      var adjustedOffset = offset + offsetChange;\n      if (result === null || result === undefined) {\n        result = text.substr(adjustedOffset, length);\n      }\n      var textArray = text.split('');\n      textArray.splice.bind(textArray, adjustedOffset, length).apply(textArray, result.split(''));\n      text = textArray.join('');\n      entities.splice.bind(entities, adjustedOffset, length).apply(entities, Array(result.length).fill(entity));\n      offsetChange += result.length - length;\n    });\n    return {\n      text: text,\n      inlines: Array(text.length).fill(inlineStyle),\n      entities: entities,\n      blocks: []\n    };\n  } // BR tags\n\n  if (nodeName === 'br') {\n    var _blockType = inBlock;\n    if (_blockType === null) {\n      //  BR tag is at top level, treat it as an unstyled block\n      return getSoftNewlineChunk('unstyled', depth, true);\n    }\n    return getSoftNewlineChunk(_blockType || 'unstyled', depth, options.flat);\n  }\n  var chunk = getEmptyChunk();\n  var newChunk = null; // Inline tags\n\n  inlineStyle = processInlineTag(nodeName, node, inlineStyle);\n  inlineStyle = processCustomInlineStyles(nodeName, node, inlineStyle); // Handle lists\n\n  if (nodeName === 'ul' || nodeName === 'ol') {\n    if (lastList) {\n      depth += 1;\n    }\n    lastList = nodeName;\n    inBlock = null;\n  } // Block Tags\n\n  var blockInfo = checkBlockType(nodeName, node, lastList, inBlock);\n  var blockType;\n  var blockDataMap;\n  if (blockInfo === false) {\n    return getEmptyChunk();\n  }\n  blockInfo = blockInfo || {};\n  if (typeof blockInfo === 'string') {\n    blockType = blockInfo;\n    blockDataMap = Map();\n  } else {\n    blockType = typeof blockInfo === 'string' ? blockInfo : blockInfo.type;\n    blockDataMap = blockInfo.data ? Map(blockInfo.data) : Map();\n  }\n  if (!inBlock && (fragmentBlockTags.indexOf(nodeName) !== -1 || blockType)) {\n    chunk = getBlockDividerChunk(blockType || getBlockTypeForTag(nodeName, lastList), depth, blockDataMap);\n    inBlock = blockType || getBlockTypeForTag(nodeName, lastList);\n    newBlock = true;\n  } else if (lastList && (inBlock === 'ordered-list-item' || inBlock === 'unordered-list-item') && nodeName === 'li') {\n    var listItemBlockType = getBlockTypeForTag(nodeName, lastList);\n    chunk = getBlockDividerChunk(listItemBlockType, depth);\n    inBlock = listItemBlockType;\n    newBlock = true;\n    nextBlockType = lastList === 'ul' ? 'unordered-list-item' : 'ordered-list-item';\n  } else if (inBlock && inBlock !== 'atomic' && blockType === 'atomic') {\n    inBlock = blockType;\n    newBlock = true;\n    chunk = getSoftNewlineChunk(blockType, depth, true,\n    // atomic blocks within non-atomic blocks must always be split out\n    blockDataMap);\n  } // Recurse through children\n\n  var child = node.firstChild; // hack to allow conversion of atomic blocks from HTML (e.g. <figure><img\n  // src=\"...\" /></figure>). since metadata must be stored on an entity text\n  // must exist for the entity to apply to. the way chunks are joined strips\n  // whitespace at the end so it cannot be a space character.\n\n  if (child == null && inEntity && (blockType === 'atomic' || inBlock === 'atomic')) {\n    child = document.createTextNode('a');\n  }\n  if (child != null) {\n    nodeName = child.nodeName.toLowerCase();\n  }\n  var entityId = null;\n  while (child) {\n    entityId = checkEntityNode(nodeName, child, createEntity, getEntity, mergeEntityData, replaceEntityData);\n    newChunk = genFragment(child, inlineStyle, lastList, inBlock, fragmentBlockTags, depth, processCustomInlineStyles, checkEntityNode, checkEntityText, checkBlockType, createEntity, getEntity, mergeEntityData, replaceEntityData, options, entityId || inEntity);\n    chunk = joinChunks(chunk, newChunk, options.flat);\n    var sibling = child.nextSibling; // Put in a newline to break up blocks inside blocks\n\n    if (sibling && fragmentBlockTags.indexOf(nodeName) >= 0 && inBlock) {\n      var newBlockInfo = checkBlockType(nodeName, child, lastList, inBlock);\n      var newBlockType = void 0;\n      var newBlockData = void 0;\n      if (newBlockInfo !== false) {\n        newBlockInfo = newBlockInfo || {};\n        if (typeof newBlockInfo === 'string') {\n          newBlockType = newBlockInfo;\n          newBlockData = Map();\n        } else {\n          newBlockType = newBlockInfo.type || getBlockTypeForTag(nodeName, lastList);\n          newBlockData = newBlockInfo.data ? Map(newBlockInfo.data) : Map();\n        }\n        chunk = joinChunks(chunk, getSoftNewlineChunk(newBlockType, depth, options.flat, newBlockData), options.flat);\n      }\n    }\n    if (sibling) {\n      nodeName = sibling.nodeName.toLowerCase();\n    }\n    child = sibling;\n  }\n  if (newBlock) {\n    chunk = joinChunks(chunk, getBlockDividerChunk(nextBlockType, depth, Map()), options.flat);\n  }\n  return chunk;\n}\nfunction getChunkForHTML(html, processCustomInlineStyles, checkEntityNode, checkEntityText, checkBlockType, createEntity, getEntity, mergeEntityData, replaceEntityData, options, DOMBuilder) {\n  html = html.trim().replace(REGEX_CR, '').replace(REGEX_NBSP, SPACE);\n  var safeBody = DOMBuilder(html);\n  if (!safeBody) {\n    return null;\n  } // Sometimes we aren't dealing with content that contains nice semantic\n  // tags. In this case, use divs to separate everything out into paragraphs\n  // and hope for the best.\n\n  var workingBlocks = containsSemanticBlockMarkup(html) ? blockTags.concat(['div']) : ['div']; // Start with -1 block depth to offset the fact that we are passing in a fake\n  // UL block to sta rt with.\n\n  var chunk = genFragment(safeBody, OrderedSet(), 'ul', null, workingBlocks, -1, processCustomInlineStyles, checkEntityNode, checkEntityText, checkBlockType, createEntity, getEntity, mergeEntityData, replaceEntityData, options); // join with previous block to prevent weirdness on paste\n\n  if (chunk.text.indexOf('\\r') === 0) {\n    chunk = {\n      text: chunk.text.slice(1),\n      inlines: chunk.inlines.slice(1),\n      entities: chunk.entities.slice(1),\n      blocks: chunk.blocks\n    };\n  } // Kill block delimiter at the end\n\n  if (chunk.text.slice(-1) === '\\r') {\n    chunk.text = chunk.text.slice(0, -1);\n    chunk.inlines = chunk.inlines.slice(0, -1);\n    chunk.entities = chunk.entities.slice(0, -1);\n    chunk.blocks.pop();\n  } // If we saw no block tags, put an unstyled one in\n\n  if (chunk.blocks.length === 0) {\n    chunk.blocks.push({\n      type: 'unstyled',\n      data: Map(),\n      depth: 0\n    });\n  } // Sometimes we start with text that isn't in a block, which is then\n  // followed by blocks. Need to fix up the blocks to add in\n  // an unstyled block for this content\n\n  if (chunk.text.split('\\r').length === chunk.blocks.length + 1) {\n    chunk.blocks.unshift({\n      type: 'unstyled',\n      data: Map(),\n      depth: 0\n    });\n  }\n  return chunk;\n}\nfunction convertFromHTMLtoContentBlocks(html, processCustomInlineStyles, checkEntityNode, checkEntityText, checkBlockType, createEntity, getEntity, mergeEntityData, replaceEntityData, options, DOMBuilder, generateKey) {\n  // Be ABSOLUTELY SURE that the dom builder you pass hare won't execute\n  // arbitrary code in whatever environment you're running this in. For an\n  // example of how we try to do this in-browser, see getSafeBodyFromHTML.\n  var chunk = getChunkForHTML(html, processCustomInlineStyles, checkEntityNode, checkEntityText, checkBlockType, createEntity, getEntity, mergeEntityData, replaceEntityData, options, DOMBuilder, generateKey);\n  if (chunk == null) {\n    return [];\n  }\n  var start = 0;\n  return chunk.text.split('\\r').map(function (textBlock, blockIndex) {\n    // Make absolutely certain that our text is acceptable.\n    textBlock = sanitizeDraftText(textBlock);\n    var end = start + textBlock.length;\n    var inlines = nullthrows(chunk).inlines.slice(start, end);\n    var entities = nullthrows(chunk).entities.slice(start, end);\n    var characterList = List(inlines.map(function (style, entityIndex) {\n      var data = {\n        style: style,\n        entity: null\n      };\n      if (entities[entityIndex]) {\n        data.entity = entities[entityIndex];\n      }\n      return CharacterMetadata.create(data);\n    }));\n    start = end + 1;\n    return new ContentBlock({\n      key: generateKey(),\n      type: nullthrows(chunk).blocks[blockIndex].type,\n      data: nullthrows(chunk).blocks[blockIndex].data,\n      depth: nullthrows(chunk).blocks[blockIndex].depth,\n      text: textBlock,\n      characterList: characterList\n    });\n  });\n}\nvar convertFromHTML = function convertFromHTML(_ref2) {\n  var _ref2$htmlToStyle = _ref2.htmlToStyle,\n    htmlToStyle = _ref2$htmlToStyle === void 0 ? defaultHTMLToStyle : _ref2$htmlToStyle,\n    _ref2$htmlToEntity = _ref2.htmlToEntity,\n    htmlToEntity = _ref2$htmlToEntity === void 0 ? defaultHTMLToEntity : _ref2$htmlToEntity,\n    _ref2$textToEntity = _ref2.textToEntity,\n    textToEntity = _ref2$textToEntity === void 0 ? defaultTextToEntity : _ref2$textToEntity,\n    _ref2$htmlToBlock = _ref2.htmlToBlock,\n    htmlToBlock = _ref2$htmlToBlock === void 0 ? defaultHTMLToBlock : _ref2$htmlToBlock;\n  return function (html) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      flat: false\n    };\n    var DOMBuilder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getSafeBodyFromHTML;\n    var generateKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : genKey;\n    var contentState = ContentState.createFromText('');\n    var createEntityWithContentState = function createEntityWithContentState() {\n      if (contentState.createEntity) {\n        var _contentState;\n        contentState = (_contentState = contentState).createEntity.apply(_contentState, arguments);\n        return contentState.getLastCreatedEntityKey();\n      }\n      return Entity.create.apply(Entity, arguments);\n    };\n    var getEntityWithContentState = function getEntityWithContentState() {\n      if (contentState.getEntity) {\n        var _contentState2;\n        return (_contentState2 = contentState).getEntity.apply(_contentState2, arguments);\n      }\n      return Entity.get.apply(Entity, arguments);\n    };\n    var mergeEntityDataWithContentState = function mergeEntityDataWithContentState() {\n      if (contentState.mergeEntityData) {\n        var _contentState3;\n        contentState = (_contentState3 = contentState).mergeEntityData.apply(_contentState3, arguments);\n        return;\n      }\n      Entity.mergeData.apply(Entity, arguments);\n    };\n    var replaceEntityDataWithContentState = function replaceEntityDataWithContentState() {\n      if (contentState.replaceEntityData) {\n        var _contentState4;\n        contentState = (_contentState4 = contentState).replaceEntityData.apply(_contentState4, arguments);\n        return;\n      }\n      Entity.replaceData.apply(Entity, arguments);\n    };\n    var contentBlocks = convertFromHTMLtoContentBlocks(html, handleMiddleware(htmlToStyle, baseProcessInlineTag), handleMiddleware(htmlToEntity, defaultHTMLToEntity), handleMiddleware(textToEntity, defaultTextToEntity), handleMiddleware(htmlToBlock, baseCheckBlockType), createEntityWithContentState, getEntityWithContentState, mergeEntityDataWithContentState, replaceEntityDataWithContentState, options, DOMBuilder, generateKey);\n    var blockMap = BlockMapBuilder.createFromArray(contentBlocks);\n    var firstBlockKey = contentBlocks[0].getKey();\n    return contentState.merge({\n      blockMap: blockMap,\n      selectionBefore: SelectionState.createEmpty(firstBlockKey),\n      selectionAfter: SelectionState.createEmpty(firstBlockKey)\n    });\n  };\n};\nexport default (function () {\n  if (arguments.length >= 1 && typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {\n    return convertFromHTML({}).apply(void 0, arguments);\n  }\n  return convertFromHTML.apply(void 0, arguments);\n});","map":{"version":3,"names":["List","OrderedSet","Map","ContentState","CharacterMetadata","ContentBlock","Entity","BlockMapBuilder","genKey","SelectionState","getSafeBodyFromHTML","rangeSort","NBSP","SPACE","MAX_DEPTH","REGEX_CR","RegExp","REGEX_LF","REGEX_NBSP","REGEX_BLOCK_DELIMITER","blockTags","inlineTags","b","code","del","em","i","s","strike","strong","u","handleMiddleware","maybeMiddleware","base","__isMiddleware","defaultHTMLToBlock","nodeName","node","lastList","undefined","defaultHTMLToStyle","currentStyle","defaultHTMLToEntity","defaultTextToEntity","text","nullthrows","x","Error","sanitizeDraftText","input","replace","getEmptyChunk","inlines","entities","blocks","getWhitespaceChunk","inEntity","Array","getSoftNewlineChunk","block","depth","flat","arguments","length","data","type","Math","max","min","isNewline","getBlockDividerChunk","getBlockTypeForTag","tag","baseCheckBlockType","processInlineTag","styleToCheck","add","toOrderedSet","HTMLElement","htmlElement","withMutations","style","fontWeight","fontStyle","textDecoration","baseProcessInlineTag","inlineStyles","joinChunks","A","B","firstInB","slice","lastInA","adjacentDividers","isJoiningBlocks","addingNewlineToEmptyBlock","pop","shift","concat","containsSemanticBlockMarkup","html","some","indexOf","genFragment","inlineStyle","inBlock","fragmentBlockTags","processCustomInlineStyles","checkEntityNode","checkEntityText","checkBlockType","createEntity","getEntity","mergeEntityData","replaceEntityData","options","toLowerCase","newBlock","nextBlockType","textContent","trim","fill","offsetChange","textEntities","sort","forEach","_ref","entity","offset","result","adjustedOffset","substr","textArray","split","splice","bind","apply","join","_blockType","chunk","newChunk","blockInfo","blockType","blockDataMap","listItemBlockType","child","firstChild","document","createTextNode","entityId","sibling","nextSibling","newBlockInfo","newBlockType","newBlockData","getChunkForHTML","DOMBuilder","safeBody","workingBlocks","push","unshift","convertFromHTMLtoContentBlocks","generateKey","start","map","textBlock","blockIndex","end","characterList","entityIndex","create","key","convertFromHTML","_ref2","_ref2$htmlToStyle","htmlToStyle","_ref2$htmlToEntity","htmlToEntity","_ref2$textToEntity","textToEntity","_ref2$htmlToBlock","htmlToBlock","contentState","createFromText","createEntityWithContentState","_contentState","getLastCreatedEntityKey","getEntityWithContentState","_contentState2","get","mergeEntityDataWithContentState","_contentState3","mergeData","replaceEntityDataWithContentState","_contentState4","replaceData","contentBlocks","blockMap","createFromArray","firstBlockKey","getKey","merge","selectionBefore","createEmpty","selectionAfter"],"sources":["/workspaces/Backwoodaroma/node_modules/draft-convert/esm/convertFromHTML.js"],"sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the /src directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\nimport { List, OrderedSet, Map } from 'immutable';\nimport { ContentState, CharacterMetadata, ContentBlock, Entity, BlockMapBuilder, genKey, SelectionState } from 'draft-js';\nimport getSafeBodyFromHTML from './util/parseHTML';\nimport rangeSort from './util/rangeSort';\nvar NBSP = '&nbsp;';\nvar SPACE = ' '; // Arbitrary max indent\n\nvar MAX_DEPTH = 4; // used for replacing characters in HTML\n\n/* eslint-disable no-control-regex */\n\nvar REGEX_CR = new RegExp('\\r', 'g');\nvar REGEX_LF = new RegExp('\\n', 'g');\nvar REGEX_NBSP = new RegExp(NBSP, 'g');\nvar REGEX_BLOCK_DELIMITER = new RegExp('\\r', 'g');\n/* eslint-enable no-control-regex */\n// Block tag flow is different because LIs do not have\n// a deterministic style ;_;\n\nvar blockTags = ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'li', 'blockquote', 'pre'];\nvar inlineTags = {\n  b: 'BOLD',\n  code: 'CODE',\n  del: 'STRIKETHROUGH',\n  em: 'ITALIC',\n  i: 'ITALIC',\n  s: 'STRIKETHROUGH',\n  strike: 'STRIKETHROUGH',\n  strong: 'BOLD',\n  u: 'UNDERLINE'\n};\n\nvar handleMiddleware = function handleMiddleware(maybeMiddleware, base) {\n  if (maybeMiddleware && maybeMiddleware.__isMiddleware === true) {\n    return maybeMiddleware(base);\n  }\n\n  return maybeMiddleware;\n};\n\nvar defaultHTMLToBlock = function defaultHTMLToBlock(nodeName, node, lastList) {\n  return undefined;\n};\n\nvar defaultHTMLToStyle = function defaultHTMLToStyle(nodeName, node, currentStyle) {\n  return currentStyle;\n};\n\nvar defaultHTMLToEntity = function defaultHTMLToEntity(nodeName, node) {\n  return undefined;\n};\n\nvar defaultTextToEntity = function defaultTextToEntity(text) {\n  return [];\n};\n\nvar nullthrows = function nullthrows(x) {\n  if (x != null) {\n    return x;\n  }\n\n  throw new Error('Got unexpected null or undefined');\n};\n\nvar sanitizeDraftText = function sanitizeDraftText(input) {\n  return input.replace(REGEX_BLOCK_DELIMITER, '');\n};\n\nfunction getEmptyChunk() {\n  return {\n    text: '',\n    inlines: [],\n    entities: [],\n    blocks: []\n  };\n}\n\nfunction getWhitespaceChunk(inEntity) {\n  var entities = new Array(1);\n\n  if (inEntity) {\n    entities[0] = inEntity;\n  }\n\n  return {\n    text: SPACE,\n    inlines: [OrderedSet()],\n    entities: entities,\n    blocks: []\n  };\n}\n\nfunction getSoftNewlineChunk(block, depth) {\n  var flat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Map();\n\n  if (flat === true) {\n    return {\n      text: '\\r',\n      inlines: [OrderedSet()],\n      entities: new Array(1),\n      blocks: [{\n        type: block,\n        data: data,\n        depth: Math.max(0, Math.min(MAX_DEPTH, depth))\n      }],\n      isNewline: true\n    };\n  }\n\n  return {\n    text: '\\n',\n    inlines: [OrderedSet()],\n    entities: new Array(1),\n    blocks: []\n  };\n}\n\nfunction getBlockDividerChunk(block, depth) {\n  var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Map();\n  return {\n    text: '\\r',\n    inlines: [OrderedSet()],\n    entities: new Array(1),\n    blocks: [{\n      type: block,\n      data: data,\n      depth: Math.max(0, Math.min(MAX_DEPTH, depth))\n    }]\n  };\n}\n\nfunction getBlockTypeForTag(tag, lastList) {\n  switch (tag) {\n    case 'h1':\n      return 'header-one';\n\n    case 'h2':\n      return 'header-two';\n\n    case 'h3':\n      return 'header-three';\n\n    case 'h4':\n      return 'header-four';\n\n    case 'h5':\n      return 'header-five';\n\n    case 'h6':\n      return 'header-six';\n\n    case 'li':\n      if (lastList === 'ol') {\n        return 'ordered-list-item';\n      }\n\n      return 'unordered-list-item';\n\n    case 'blockquote':\n      return 'blockquote';\n\n    case 'pre':\n      return 'code-block';\n\n    case 'div':\n    case 'p':\n      return 'unstyled';\n\n    default:\n      return null;\n  }\n}\n\nfunction baseCheckBlockType(nodeName, node, lastList) {\n  return getBlockTypeForTag(nodeName, lastList);\n}\n\nfunction processInlineTag(tag, node, currentStyle) {\n  var styleToCheck = inlineTags[tag];\n\n  if (styleToCheck) {\n    currentStyle = currentStyle.add(styleToCheck).toOrderedSet();\n  } else if (node instanceof HTMLElement) {\n    var htmlElement = node;\n    currentStyle = currentStyle.withMutations(function (style) {\n      if (htmlElement.style.fontWeight === 'bold') {\n        style.add('BOLD');\n      }\n\n      if (htmlElement.style.fontStyle === 'italic') {\n        style.add('ITALIC');\n      }\n\n      if (htmlElement.style.textDecoration === 'underline') {\n        style.add('UNDERLINE');\n      }\n\n      if (htmlElement.style.textDecoration === 'line-through') {\n        style.add('STRIKETHROUGH');\n      }\n    }).toOrderedSet();\n  }\n\n  return currentStyle;\n}\n\nfunction baseProcessInlineTag(tag, node) {\n  var inlineStyles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : OrderedSet();\n  return processInlineTag(tag, node, inlineStyles);\n}\n\nfunction joinChunks(A, B) {\n  var flat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // Sometimes two blocks will touch in the DOM and we need to strip the\n  // extra delimiter to preserve niceness.\n  var firstInB = B.text.slice(0, 1);\n  var lastInA = A.text.slice(-1);\n  var adjacentDividers = lastInA === '\\r' && firstInB === '\\r';\n  var isJoiningBlocks = A.text !== '\\r' && B.text !== '\\r'; // when joining two full blocks like this we want to pop one divider\n\n  var addingNewlineToEmptyBlock = A.text === '\\r' && !A.isNewline && B.isNewline; // when joining a newline to an empty block we want to remove the newline\n\n  if (adjacentDividers && (isJoiningBlocks || addingNewlineToEmptyBlock)) {\n    A.text = A.text.slice(0, -1);\n    A.inlines.pop();\n    A.entities.pop();\n    A.blocks.pop();\n  } // Kill whitespace after blocks if flat mode is on\n\n\n  if (A.text.slice(-1) === '\\r' && flat === true) {\n    if (B.text === SPACE || B.text === '\\n') {\n      return A;\n    } else if (firstInB === SPACE || firstInB === '\\n') {\n      B.text = B.text.slice(1);\n      B.inlines.shift();\n      B.entities.shift();\n    }\n  }\n\n  var isNewline = A.text.length === 0 && B.isNewline;\n  return {\n    text: A.text + B.text,\n    inlines: A.inlines.concat(B.inlines),\n    entities: A.entities.concat(B.entities),\n    blocks: A.blocks.concat(B.blocks),\n    isNewline: isNewline\n  };\n}\n/*\n * Check to see if we have anything like <p> <blockquote> <h1>... to create\n * block tags from. If we do, we can use those and ignore <div> tags. If we\n * don't, we can treat <div> tags as meaningful (unstyled) blocks.\n */\n\n\nfunction containsSemanticBlockMarkup(html) {\n  return blockTags.some(function (tag) {\n    return html.indexOf(\"<\".concat(tag)) !== -1;\n  });\n}\n\nfunction genFragment(node, inlineStyle, lastList, inBlock, fragmentBlockTags, depth, processCustomInlineStyles, checkEntityNode, checkEntityText, checkBlockType, createEntity, getEntity, mergeEntityData, replaceEntityData, options, inEntity) {\n  var nodeName = node.nodeName.toLowerCase();\n  var newBlock = false;\n  var nextBlockType = 'unstyled'; // Base Case\n\n  if (nodeName === '#text') {\n    var text = node.textContent;\n\n    if (text.trim() === '' && inBlock === null) {\n      return getEmptyChunk();\n    }\n\n    if (text.trim() === '' && inBlock !== 'code-block') {\n      return getWhitespaceChunk(inEntity);\n    }\n\n    if (inBlock !== 'code-block') {\n      // Can't use empty string because MSWord\n      text = text.replace(REGEX_LF, SPACE);\n    }\n\n    var entities = Array(text.length).fill(inEntity);\n    var offsetChange = 0;\n    var textEntities = checkEntityText(text, createEntity, getEntity, mergeEntityData, replaceEntityData).sort(rangeSort);\n    textEntities.forEach(function (_ref) {\n      var entity = _ref.entity,\n          offset = _ref.offset,\n          length = _ref.length,\n          result = _ref.result;\n      var adjustedOffset = offset + offsetChange;\n\n      if (result === null || result === undefined) {\n        result = text.substr(adjustedOffset, length);\n      }\n\n      var textArray = text.split('');\n      textArray.splice.bind(textArray, adjustedOffset, length).apply(textArray, result.split(''));\n      text = textArray.join('');\n      entities.splice.bind(entities, adjustedOffset, length).apply(entities, Array(result.length).fill(entity));\n      offsetChange += result.length - length;\n    });\n    return {\n      text: text,\n      inlines: Array(text.length).fill(inlineStyle),\n      entities: entities,\n      blocks: []\n    };\n  } // BR tags\n\n\n  if (nodeName === 'br') {\n    var _blockType = inBlock;\n\n    if (_blockType === null) {\n      //  BR tag is at top level, treat it as an unstyled block\n      return getSoftNewlineChunk('unstyled', depth, true);\n    }\n\n    return getSoftNewlineChunk(_blockType || 'unstyled', depth, options.flat);\n  }\n\n  var chunk = getEmptyChunk();\n  var newChunk = null; // Inline tags\n\n  inlineStyle = processInlineTag(nodeName, node, inlineStyle);\n  inlineStyle = processCustomInlineStyles(nodeName, node, inlineStyle); // Handle lists\n\n  if (nodeName === 'ul' || nodeName === 'ol') {\n    if (lastList) {\n      depth += 1;\n    }\n\n    lastList = nodeName;\n    inBlock = null;\n  } // Block Tags\n\n\n  var blockInfo = checkBlockType(nodeName, node, lastList, inBlock);\n  var blockType;\n  var blockDataMap;\n\n  if (blockInfo === false) {\n    return getEmptyChunk();\n  }\n\n  blockInfo = blockInfo || {};\n\n  if (typeof blockInfo === 'string') {\n    blockType = blockInfo;\n    blockDataMap = Map();\n  } else {\n    blockType = typeof blockInfo === 'string' ? blockInfo : blockInfo.type;\n    blockDataMap = blockInfo.data ? Map(blockInfo.data) : Map();\n  }\n\n  if (!inBlock && (fragmentBlockTags.indexOf(nodeName) !== -1 || blockType)) {\n    chunk = getBlockDividerChunk(blockType || getBlockTypeForTag(nodeName, lastList), depth, blockDataMap);\n    inBlock = blockType || getBlockTypeForTag(nodeName, lastList);\n    newBlock = true;\n  } else if (lastList && (inBlock === 'ordered-list-item' || inBlock === 'unordered-list-item') && nodeName === 'li') {\n    var listItemBlockType = getBlockTypeForTag(nodeName, lastList);\n    chunk = getBlockDividerChunk(listItemBlockType, depth);\n    inBlock = listItemBlockType;\n    newBlock = true;\n    nextBlockType = lastList === 'ul' ? 'unordered-list-item' : 'ordered-list-item';\n  } else if (inBlock && inBlock !== 'atomic' && blockType === 'atomic') {\n    inBlock = blockType;\n    newBlock = true;\n    chunk = getSoftNewlineChunk(blockType, depth, true, // atomic blocks within non-atomic blocks must always be split out\n    blockDataMap);\n  } // Recurse through children\n\n\n  var child = node.firstChild; // hack to allow conversion of atomic blocks from HTML (e.g. <figure><img\n  // src=\"...\" /></figure>). since metadata must be stored on an entity text\n  // must exist for the entity to apply to. the way chunks are joined strips\n  // whitespace at the end so it cannot be a space character.\n\n  if (child == null && inEntity && (blockType === 'atomic' || inBlock === 'atomic')) {\n    child = document.createTextNode('a');\n  }\n\n  if (child != null) {\n    nodeName = child.nodeName.toLowerCase();\n  }\n\n  var entityId = null;\n\n  while (child) {\n    entityId = checkEntityNode(nodeName, child, createEntity, getEntity, mergeEntityData, replaceEntityData);\n    newChunk = genFragment(child, inlineStyle, lastList, inBlock, fragmentBlockTags, depth, processCustomInlineStyles, checkEntityNode, checkEntityText, checkBlockType, createEntity, getEntity, mergeEntityData, replaceEntityData, options, entityId || inEntity);\n    chunk = joinChunks(chunk, newChunk, options.flat);\n    var sibling = child.nextSibling; // Put in a newline to break up blocks inside blocks\n\n    if (sibling && fragmentBlockTags.indexOf(nodeName) >= 0 && inBlock) {\n      var newBlockInfo = checkBlockType(nodeName, child, lastList, inBlock);\n      var newBlockType = void 0;\n      var newBlockData = void 0;\n\n      if (newBlockInfo !== false) {\n        newBlockInfo = newBlockInfo || {};\n\n        if (typeof newBlockInfo === 'string') {\n          newBlockType = newBlockInfo;\n          newBlockData = Map();\n        } else {\n          newBlockType = newBlockInfo.type || getBlockTypeForTag(nodeName, lastList);\n          newBlockData = newBlockInfo.data ? Map(newBlockInfo.data) : Map();\n        }\n\n        chunk = joinChunks(chunk, getSoftNewlineChunk(newBlockType, depth, options.flat, newBlockData), options.flat);\n      }\n    }\n\n    if (sibling) {\n      nodeName = sibling.nodeName.toLowerCase();\n    }\n\n    child = sibling;\n  }\n\n  if (newBlock) {\n    chunk = joinChunks(chunk, getBlockDividerChunk(nextBlockType, depth, Map()), options.flat);\n  }\n\n  return chunk;\n}\n\nfunction getChunkForHTML(html, processCustomInlineStyles, checkEntityNode, checkEntityText, checkBlockType, createEntity, getEntity, mergeEntityData, replaceEntityData, options, DOMBuilder) {\n  html = html.trim().replace(REGEX_CR, '').replace(REGEX_NBSP, SPACE);\n  var safeBody = DOMBuilder(html);\n\n  if (!safeBody) {\n    return null;\n  } // Sometimes we aren't dealing with content that contains nice semantic\n  // tags. In this case, use divs to separate everything out into paragraphs\n  // and hope for the best.\n\n\n  var workingBlocks = containsSemanticBlockMarkup(html) ? blockTags.concat(['div']) : ['div']; // Start with -1 block depth to offset the fact that we are passing in a fake\n  // UL block to sta rt with.\n\n  var chunk = genFragment(safeBody, OrderedSet(), 'ul', null, workingBlocks, -1, processCustomInlineStyles, checkEntityNode, checkEntityText, checkBlockType, createEntity, getEntity, mergeEntityData, replaceEntityData, options); // join with previous block to prevent weirdness on paste\n\n  if (chunk.text.indexOf('\\r') === 0) {\n    chunk = {\n      text: chunk.text.slice(1),\n      inlines: chunk.inlines.slice(1),\n      entities: chunk.entities.slice(1),\n      blocks: chunk.blocks\n    };\n  } // Kill block delimiter at the end\n\n\n  if (chunk.text.slice(-1) === '\\r') {\n    chunk.text = chunk.text.slice(0, -1);\n    chunk.inlines = chunk.inlines.slice(0, -1);\n    chunk.entities = chunk.entities.slice(0, -1);\n    chunk.blocks.pop();\n  } // If we saw no block tags, put an unstyled one in\n\n\n  if (chunk.blocks.length === 0) {\n    chunk.blocks.push({\n      type: 'unstyled',\n      data: Map(),\n      depth: 0\n    });\n  } // Sometimes we start with text that isn't in a block, which is then\n  // followed by blocks. Need to fix up the blocks to add in\n  // an unstyled block for this content\n\n\n  if (chunk.text.split('\\r').length === chunk.blocks.length + 1) {\n    chunk.blocks.unshift({\n      type: 'unstyled',\n      data: Map(),\n      depth: 0\n    });\n  }\n\n  return chunk;\n}\n\nfunction convertFromHTMLtoContentBlocks(html, processCustomInlineStyles, checkEntityNode, checkEntityText, checkBlockType, createEntity, getEntity, mergeEntityData, replaceEntityData, options, DOMBuilder, generateKey) {\n  // Be ABSOLUTELY SURE that the dom builder you pass hare won't execute\n  // arbitrary code in whatever environment you're running this in. For an\n  // example of how we try to do this in-browser, see getSafeBodyFromHTML.\n  var chunk = getChunkForHTML(html, processCustomInlineStyles, checkEntityNode, checkEntityText, checkBlockType, createEntity, getEntity, mergeEntityData, replaceEntityData, options, DOMBuilder, generateKey);\n\n  if (chunk == null) {\n    return [];\n  }\n\n  var start = 0;\n  return chunk.text.split('\\r').map(function (textBlock, blockIndex) {\n    // Make absolutely certain that our text is acceptable.\n    textBlock = sanitizeDraftText(textBlock);\n    var end = start + textBlock.length;\n    var inlines = nullthrows(chunk).inlines.slice(start, end);\n    var entities = nullthrows(chunk).entities.slice(start, end);\n    var characterList = List(inlines.map(function (style, entityIndex) {\n      var data = {\n        style: style,\n        entity: null\n      };\n\n      if (entities[entityIndex]) {\n        data.entity = entities[entityIndex];\n      }\n\n      return CharacterMetadata.create(data);\n    }));\n    start = end + 1;\n    return new ContentBlock({\n      key: generateKey(),\n      type: nullthrows(chunk).blocks[blockIndex].type,\n      data: nullthrows(chunk).blocks[blockIndex].data,\n      depth: nullthrows(chunk).blocks[blockIndex].depth,\n      text: textBlock,\n      characterList: characterList\n    });\n  });\n}\n\nvar convertFromHTML = function convertFromHTML(_ref2) {\n  var _ref2$htmlToStyle = _ref2.htmlToStyle,\n      htmlToStyle = _ref2$htmlToStyle === void 0 ? defaultHTMLToStyle : _ref2$htmlToStyle,\n      _ref2$htmlToEntity = _ref2.htmlToEntity,\n      htmlToEntity = _ref2$htmlToEntity === void 0 ? defaultHTMLToEntity : _ref2$htmlToEntity,\n      _ref2$textToEntity = _ref2.textToEntity,\n      textToEntity = _ref2$textToEntity === void 0 ? defaultTextToEntity : _ref2$textToEntity,\n      _ref2$htmlToBlock = _ref2.htmlToBlock,\n      htmlToBlock = _ref2$htmlToBlock === void 0 ? defaultHTMLToBlock : _ref2$htmlToBlock;\n  return function (html) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      flat: false\n    };\n    var DOMBuilder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getSafeBodyFromHTML;\n    var generateKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : genKey;\n    var contentState = ContentState.createFromText('');\n\n    var createEntityWithContentState = function createEntityWithContentState() {\n      if (contentState.createEntity) {\n        var _contentState;\n\n        contentState = (_contentState = contentState).createEntity.apply(_contentState, arguments);\n        return contentState.getLastCreatedEntityKey();\n      }\n\n      return Entity.create.apply(Entity, arguments);\n    };\n\n    var getEntityWithContentState = function getEntityWithContentState() {\n      if (contentState.getEntity) {\n        var _contentState2;\n\n        return (_contentState2 = contentState).getEntity.apply(_contentState2, arguments);\n      }\n\n      return Entity.get.apply(Entity, arguments);\n    };\n\n    var mergeEntityDataWithContentState = function mergeEntityDataWithContentState() {\n      if (contentState.mergeEntityData) {\n        var _contentState3;\n\n        contentState = (_contentState3 = contentState).mergeEntityData.apply(_contentState3, arguments);\n        return;\n      }\n\n      Entity.mergeData.apply(Entity, arguments);\n    };\n\n    var replaceEntityDataWithContentState = function replaceEntityDataWithContentState() {\n      if (contentState.replaceEntityData) {\n        var _contentState4;\n\n        contentState = (_contentState4 = contentState).replaceEntityData.apply(_contentState4, arguments);\n        return;\n      }\n\n      Entity.replaceData.apply(Entity, arguments);\n    };\n\n    var contentBlocks = convertFromHTMLtoContentBlocks(html, handleMiddleware(htmlToStyle, baseProcessInlineTag), handleMiddleware(htmlToEntity, defaultHTMLToEntity), handleMiddleware(textToEntity, defaultTextToEntity), handleMiddleware(htmlToBlock, baseCheckBlockType), createEntityWithContentState, getEntityWithContentState, mergeEntityDataWithContentState, replaceEntityDataWithContentState, options, DOMBuilder, generateKey);\n    var blockMap = BlockMapBuilder.createFromArray(contentBlocks);\n    var firstBlockKey = contentBlocks[0].getKey();\n    return contentState.merge({\n      blockMap: blockMap,\n      selectionBefore: SelectionState.createEmpty(firstBlockKey),\n      selectionAfter: SelectionState.createEmpty(firstBlockKey)\n    });\n  };\n};\n\nexport default (function () {\n  if (arguments.length >= 1 && typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {\n    return convertFromHTML({}).apply(void 0, arguments);\n  }\n\n  return convertFromHTML.apply(void 0, arguments);\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}