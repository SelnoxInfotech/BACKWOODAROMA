{"ast":null,"code":"import _toConsumableArray from \"/workspaces/Backwoodaroma/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/workspaces/Backwoodaroma/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridRegisterPipeProcessor } from '@mui/x-data-grid/internals';\nimport { gridPinnedColumnsSelector } from './gridColumnPinningSelector';\nimport { columnPinningStateInitializer } from './useGridColumnPinning';\nimport { filterColumns } from '../../../components/DataGridProVirtualScroller';\nexport var useGridColumnPinningPreProcessors = function useGridColumnPinningPreProcessors(apiRef, props) {\n  var disableColumnPinning = props.disableColumnPinning,\n    pinnedColumnsProp = props.pinnedColumns,\n    initialState = props.initialState;\n  var pinnedColumns = gridPinnedColumnsSelector(apiRef.current.state);\n  if (pinnedColumns == null) {\n    // Since the state is not ready yet lets use the initializer to get which\n    // columns should be pinned initially.\n    var initializedState = columnPinningStateInitializer(apiRef.current.state, {\n      disableColumnPinning: disableColumnPinning,\n      pinnedColumns: pinnedColumnsProp,\n      initialState: initialState\n    }, apiRef);\n    pinnedColumns = gridPinnedColumnsSelector(initializedState);\n  }\n  var prevAllPinnedColumns = React.useRef();\n  var reorderPinnedColumns = React.useCallback(function (columnsState) {\n    if (columnsState.all.length === 0 || disableColumnPinning) {\n      return columnsState;\n    }\n    var _filterColumns = filterColumns(pinnedColumns, columnsState.all),\n      _filterColumns2 = _slicedToArray(_filterColumns, 2),\n      leftPinnedColumns = _filterColumns2[0],\n      rightPinnedColumns = _filterColumns2[1];\n    var newOrderedFields;\n    var allPinnedColumns = [].concat(_toConsumableArray(leftPinnedColumns), _toConsumableArray(rightPinnedColumns));\n    var orderedFieldsBeforePinningColumns = apiRef.current.unstable_caches.columnPinning.orderedFieldsBeforePinningColumns;\n    if (orderedFieldsBeforePinningColumns) {\n      newOrderedFields = new Array(columnsState.all.length).fill(null);\n      var newOrderedFieldsBeforePinningColumns = _toConsumableArray(newOrderedFields); // Contains the fields not added to the orderedFields array yet\n\n      var remainingFields = _toConsumableArray(columnsState.all); // First, we check if the column was unpinned since the last processing.\n      // If yes and it still exists, we move it back to the same position it was before pinning\n\n      prevAllPinnedColumns.current.forEach(function (field) {\n        if (!allPinnedColumns.includes(field) && columnsState.lookup[field]) {\n          // Get the position before pinning\n          var index = orderedFieldsBeforePinningColumns.indexOf(field);\n          newOrderedFields[index] = field;\n          newOrderedFieldsBeforePinningColumns[index] = field; // This field was already consumed so we prevent from being added again\n\n          remainingFields.splice(remainingFields.indexOf(field), 1);\n        }\n      }); // For columns still pinned, we keep stored their original positions\n\n      allPinnedColumns.forEach(function (field) {\n        var index = orderedFieldsBeforePinningColumns.indexOf(field); // If index = -1, the pinned field didn't exist in the last processing, it's possibly being added now\n        // If index >= newOrderedFieldsBeforePinningColumns.length, then one or more columns were removed\n        // In both cases, use the position from the columns array\n        // TODO: detect removed columns and decrease the positions after it\n\n        if (index === -1 || index >= newOrderedFieldsBeforePinningColumns.length) {\n          index = columnsState.all.indexOf(field);\n        } // The fallback above may make the column to be inserted in a position already occupied\n        // In this case, put it in any empty slot available\n\n        if (newOrderedFieldsBeforePinningColumns[index] !== null) {\n          index = 0;\n          while (newOrderedFieldsBeforePinningColumns[index] !== null) {\n            index += 1;\n          }\n        }\n        newOrderedFields[index] = field;\n        newOrderedFieldsBeforePinningColumns[index] = field; // This field was already consumed so we prevent from being added again\n\n        remainingFields.splice(remainingFields.indexOf(field), 1);\n      }); // The fields remaining are those that're neither pinnned nor were unpinned\n      // For these, we spread them across both arrays making sure to not override existing values\n\n      var i = 0;\n      remainingFields.forEach(function (field) {\n        while (newOrderedFieldsBeforePinningColumns[i] !== null) {\n          i += 1;\n        }\n        newOrderedFieldsBeforePinningColumns[i] = field;\n        newOrderedFields[i] = field;\n      });\n      apiRef.current.unstable_caches.columnPinning.orderedFieldsBeforePinningColumns = newOrderedFieldsBeforePinningColumns;\n    } else {\n      newOrderedFields = _toConsumableArray(columnsState.all);\n      apiRef.current.unstable_caches.columnPinning.orderedFieldsBeforePinningColumns = _toConsumableArray(columnsState.all);\n    }\n    prevAllPinnedColumns.current = allPinnedColumns;\n    var centerColumns = newOrderedFields.filter(function (field) {\n      return !leftPinnedColumns.includes(field) && !rightPinnedColumns.includes(field);\n    });\n    return _extends({}, columnsState, {\n      all: [].concat(_toConsumableArray(leftPinnedColumns), _toConsumableArray(centerColumns), _toConsumableArray(rightPinnedColumns))\n    });\n  }, [apiRef, disableColumnPinning, pinnedColumns]);\n  useGridRegisterPipeProcessor(apiRef, 'hydrateColumns', reorderPinnedColumns);\n};","map":{"version":3,"names":["_extends","React","useGridRegisterPipeProcessor","gridPinnedColumnsSelector","columnPinningStateInitializer","filterColumns","useGridColumnPinningPreProcessors","apiRef","props","disableColumnPinning","pinnedColumnsProp","pinnedColumns","initialState","current","state","initializedState","prevAllPinnedColumns","useRef","reorderPinnedColumns","useCallback","columnsState","all","length","leftPinnedColumns","rightPinnedColumns","newOrderedFields","allPinnedColumns","orderedFieldsBeforePinningColumns","unstable_caches","columnPinning","Array","fill","newOrderedFieldsBeforePinningColumns","remainingFields","forEach","field","includes","lookup","index","indexOf","splice","i","centerColumns","filter"],"sources":["/workspaces/Backwoodaroma/node_modules/@mui/x-data-grid-pro/hooks/features/columnPinning/useGridColumnPinningPreProcessors.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridRegisterPipeProcessor } from '@mui/x-data-grid/internals';\nimport { gridPinnedColumnsSelector } from './gridColumnPinningSelector';\nimport { columnPinningStateInitializer } from './useGridColumnPinning';\nimport { filterColumns } from '../../../components/DataGridProVirtualScroller';\nexport const useGridColumnPinningPreProcessors = (apiRef, props) => {\n  const {\n    disableColumnPinning,\n    pinnedColumns: pinnedColumnsProp,\n    initialState\n  } = props;\n  let pinnedColumns = gridPinnedColumnsSelector(apiRef.current.state);\n\n  if (pinnedColumns == null) {\n    // Since the state is not ready yet lets use the initializer to get which\n    // columns should be pinned initially.\n    const initializedState = columnPinningStateInitializer(apiRef.current.state, {\n      disableColumnPinning,\n      pinnedColumns: pinnedColumnsProp,\n      initialState\n    }, apiRef);\n    pinnedColumns = gridPinnedColumnsSelector(initializedState);\n  }\n\n  const prevAllPinnedColumns = React.useRef();\n  const reorderPinnedColumns = React.useCallback(columnsState => {\n    if (columnsState.all.length === 0 || disableColumnPinning) {\n      return columnsState;\n    }\n\n    const [leftPinnedColumns, rightPinnedColumns] = filterColumns(pinnedColumns, columnsState.all);\n    let newOrderedFields;\n    const allPinnedColumns = [...leftPinnedColumns, ...rightPinnedColumns];\n    const {\n      orderedFieldsBeforePinningColumns\n    } = apiRef.current.unstable_caches.columnPinning;\n\n    if (orderedFieldsBeforePinningColumns) {\n      newOrderedFields = new Array(columnsState.all.length).fill(null);\n      const newOrderedFieldsBeforePinningColumns = [...newOrderedFields]; // Contains the fields not added to the orderedFields array yet\n\n      const remainingFields = [...columnsState.all]; // First, we check if the column was unpinned since the last processing.\n      // If yes and it still exists, we move it back to the same position it was before pinning\n\n      prevAllPinnedColumns.current.forEach(field => {\n        if (!allPinnedColumns.includes(field) && columnsState.lookup[field]) {\n          // Get the position before pinning\n          const index = orderedFieldsBeforePinningColumns.indexOf(field);\n          newOrderedFields[index] = field;\n          newOrderedFieldsBeforePinningColumns[index] = field; // This field was already consumed so we prevent from being added again\n\n          remainingFields.splice(remainingFields.indexOf(field), 1);\n        }\n      }); // For columns still pinned, we keep stored their original positions\n\n      allPinnedColumns.forEach(field => {\n        let index = orderedFieldsBeforePinningColumns.indexOf(field); // If index = -1, the pinned field didn't exist in the last processing, it's possibly being added now\n        // If index >= newOrderedFieldsBeforePinningColumns.length, then one or more columns were removed\n        // In both cases, use the position from the columns array\n        // TODO: detect removed columns and decrease the positions after it\n\n        if (index === -1 || index >= newOrderedFieldsBeforePinningColumns.length) {\n          index = columnsState.all.indexOf(field);\n        } // The fallback above may make the column to be inserted in a position already occupied\n        // In this case, put it in any empty slot available\n\n\n        if (newOrderedFieldsBeforePinningColumns[index] !== null) {\n          index = 0;\n\n          while (newOrderedFieldsBeforePinningColumns[index] !== null) {\n            index += 1;\n          }\n        }\n\n        newOrderedFields[index] = field;\n        newOrderedFieldsBeforePinningColumns[index] = field; // This field was already consumed so we prevent from being added again\n\n        remainingFields.splice(remainingFields.indexOf(field), 1);\n      }); // The fields remaining are those that're neither pinnned nor were unpinned\n      // For these, we spread them across both arrays making sure to not override existing values\n\n      let i = 0;\n      remainingFields.forEach(field => {\n        while (newOrderedFieldsBeforePinningColumns[i] !== null) {\n          i += 1;\n        }\n\n        newOrderedFieldsBeforePinningColumns[i] = field;\n        newOrderedFields[i] = field;\n      });\n      apiRef.current.unstable_caches.columnPinning.orderedFieldsBeforePinningColumns = newOrderedFieldsBeforePinningColumns;\n    } else {\n      newOrderedFields = [...columnsState.all];\n      apiRef.current.unstable_caches.columnPinning.orderedFieldsBeforePinningColumns = [...columnsState.all];\n    }\n\n    prevAllPinnedColumns.current = allPinnedColumns;\n    const centerColumns = newOrderedFields.filter(field => {\n      return !leftPinnedColumns.includes(field) && !rightPinnedColumns.includes(field);\n    });\n    return _extends({}, columnsState, {\n      all: [...leftPinnedColumns, ...centerColumns, ...rightPinnedColumns]\n    });\n  }, [apiRef, disableColumnPinning, pinnedColumns]);\n  useGridRegisterPipeProcessor(apiRef, 'hydrateColumns', reorderPinnedColumns);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}