{"ast":null,"code":"import _defineProperty from \"/workspaces/Backwoodaroma/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _toConsumableArray from \"/workspaces/Backwoodaroma/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridRegisterPipeProcessor } from '@mui/x-data-grid/internals';\nexport function addPinnedRow(_ref) {\n  var groupingParams = _ref.groupingParams,\n    rowModel = _ref.rowModel,\n    rowId = _ref.rowId,\n    position = _ref.position,\n    apiRef = _ref.apiRef;\n  var _groupingParams$addit;\n  var idRowsLookup = _extends({}, groupingParams.idRowsLookup);\n  var tree = _extends({}, groupingParams.tree); // TODO: warn if id is already present in `props.rows`\n\n  idRowsLookup[rowId] = rowModel; // Do not push it to ids list so that pagination is not affected by pinned rows\n  // ids.push(rowId);\n\n  tree[rowId] = {\n    id: rowId,\n    isAutoGenerated: false,\n    parent: null,\n    depth: 0,\n    groupingKey: null,\n    groupingField: null,\n    isPinned: true\n  };\n  apiRef.current.unstable_caches.rows.idRowsLookup[rowId] = _extends({}, rowModel);\n  apiRef.current.unstable_caches.rows.idToIdLookup[rowId] = rowId;\n  var previousPinnedRows = ((_groupingParams$addit = groupingParams.additionalRowGroups) == null ? void 0 : _groupingParams$addit.pinnedRows) || {};\n  var newPinnedRow = {\n    id: rowId,\n    model: rowModel\n  };\n  return _extends({}, groupingParams, {\n    idRowsLookup: idRowsLookup,\n    tree: tree,\n    additionalRowGroups: _extends({}, groupingParams.additionalRowGroups, {\n      pinnedRows: _extends({}, previousPinnedRows, _defineProperty({}, position, [].concat(_toConsumableArray(previousPinnedRows[position] || []), [newPinnedRow])))\n    })\n  });\n}\nexport var useGridRowPinningPreProcessors = function useGridRowPinningPreProcessors(apiRef) {\n  var addPinnedRows = React.useCallback(function (groupingParams) {\n    var _pinnedRowsCache$topI, _pinnedRowsCache$bott;\n    var pinnedRowsCache = apiRef.current.unstable_caches.pinnedRows || {};\n    var newGroupingParams = _extends({}, groupingParams, {\n      additionalRowGroups: _extends({}, groupingParams.additionalRowGroups, {\n        // reset pinned rows state\n        pinnedRows: {}\n      })\n    });\n    (_pinnedRowsCache$topI = pinnedRowsCache.topIds) == null ? void 0 : _pinnedRowsCache$topI.forEach(function (rowId) {\n      newGroupingParams = addPinnedRow({\n        groupingParams: newGroupingParams,\n        rowModel: pinnedRowsCache.idLookup[rowId],\n        rowId: rowId,\n        position: 'top',\n        apiRef: apiRef\n      });\n    });\n    (_pinnedRowsCache$bott = pinnedRowsCache.bottomIds) == null ? void 0 : _pinnedRowsCache$bott.forEach(function (rowId) {\n      newGroupingParams = addPinnedRow({\n        groupingParams: newGroupingParams,\n        rowModel: pinnedRowsCache.idLookup[rowId],\n        rowId: rowId,\n        position: 'bottom',\n        apiRef: apiRef\n      });\n    }); // If row with the same `id` is present both in `rows` and `pinnedRows` - remove it from `ids`\n\n    newGroupingParams.ids = newGroupingParams.ids.filter(function (rowId) {\n      if (newGroupingParams.tree[rowId] && newGroupingParams.tree[rowId].isPinned) {\n        return false;\n      }\n      return true;\n    });\n    return newGroupingParams;\n  }, [apiRef]);\n  useGridRegisterPipeProcessor(apiRef, 'hydrateRows', addPinnedRows);\n};","map":{"version":3,"names":["_extends","React","useGridRegisterPipeProcessor","addPinnedRow","groupingParams","rowModel","rowId","position","apiRef","_groupingParams$addit","idRowsLookup","tree","id","isAutoGenerated","parent","depth","groupingKey","groupingField","isPinned","current","unstable_caches","rows","idToIdLookup","previousPinnedRows","additionalRowGroups","pinnedRows","newPinnedRow","model","useGridRowPinningPreProcessors","addPinnedRows","useCallback","_pinnedRowsCache$topI","_pinnedRowsCache$bott","pinnedRowsCache","newGroupingParams","topIds","forEach","idLookup","bottomIds","ids","filter"],"sources":["/workspaces/Backwoodaroma/node_modules/@mui/x-data-grid-pro/hooks/features/rowPinning/useGridRowPinningPreProcessors.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridRegisterPipeProcessor } from '@mui/x-data-grid/internals';\nexport function addPinnedRow({\n  groupingParams,\n  rowModel,\n  rowId,\n  position,\n  apiRef\n}) {\n  var _groupingParams$addit;\n\n  const idRowsLookup = _extends({}, groupingParams.idRowsLookup);\n\n  const tree = _extends({}, groupingParams.tree); // TODO: warn if id is already present in `props.rows`\n\n\n  idRowsLookup[rowId] = rowModel; // Do not push it to ids list so that pagination is not affected by pinned rows\n  // ids.push(rowId);\n\n  tree[rowId] = {\n    id: rowId,\n    isAutoGenerated: false,\n    parent: null,\n    depth: 0,\n    groupingKey: null,\n    groupingField: null,\n    isPinned: true\n  };\n  apiRef.current.unstable_caches.rows.idRowsLookup[rowId] = _extends({}, rowModel);\n  apiRef.current.unstable_caches.rows.idToIdLookup[rowId] = rowId;\n  const previousPinnedRows = ((_groupingParams$addit = groupingParams.additionalRowGroups) == null ? void 0 : _groupingParams$addit.pinnedRows) || {};\n  const newPinnedRow = {\n    id: rowId,\n    model: rowModel\n  };\n  return _extends({}, groupingParams, {\n    idRowsLookup,\n    tree,\n    additionalRowGroups: _extends({}, groupingParams.additionalRowGroups, {\n      pinnedRows: _extends({}, previousPinnedRows, {\n        [position]: [...(previousPinnedRows[position] || []), newPinnedRow]\n      })\n    })\n  });\n}\nexport const useGridRowPinningPreProcessors = apiRef => {\n  const addPinnedRows = React.useCallback(groupingParams => {\n    var _pinnedRowsCache$topI, _pinnedRowsCache$bott;\n\n    const pinnedRowsCache = apiRef.current.unstable_caches.pinnedRows || {};\n\n    let newGroupingParams = _extends({}, groupingParams, {\n      additionalRowGroups: _extends({}, groupingParams.additionalRowGroups, {\n        // reset pinned rows state\n        pinnedRows: {}\n      })\n    });\n\n    (_pinnedRowsCache$topI = pinnedRowsCache.topIds) == null ? void 0 : _pinnedRowsCache$topI.forEach(rowId => {\n      newGroupingParams = addPinnedRow({\n        groupingParams: newGroupingParams,\n        rowModel: pinnedRowsCache.idLookup[rowId],\n        rowId,\n        position: 'top',\n        apiRef\n      });\n    });\n    (_pinnedRowsCache$bott = pinnedRowsCache.bottomIds) == null ? void 0 : _pinnedRowsCache$bott.forEach(rowId => {\n      newGroupingParams = addPinnedRow({\n        groupingParams: newGroupingParams,\n        rowModel: pinnedRowsCache.idLookup[rowId],\n        rowId,\n        position: 'bottom',\n        apiRef\n      });\n    }); // If row with the same `id` is present both in `rows` and `pinnedRows` - remove it from `ids`\n\n    newGroupingParams.ids = newGroupingParams.ids.filter(rowId => {\n      if (newGroupingParams.tree[rowId] && newGroupingParams.tree[rowId].isPinned) {\n        return false;\n      }\n\n      return true;\n    });\n    return newGroupingParams;\n  }, [apiRef]);\n  useGridRegisterPipeProcessor(apiRef, 'hydrateRows', addPinnedRows);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}