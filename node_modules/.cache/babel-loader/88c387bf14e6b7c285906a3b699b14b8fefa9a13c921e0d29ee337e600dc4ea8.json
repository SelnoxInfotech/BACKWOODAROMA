{"ast":null,"code":"import _toConsumableArray from \"/workspaces/Backwoodaroma/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nexport var getGroupRowIdFromPath = function getGroupRowIdFromPath(path) {\n  var pathStr = path.map(function (groupingCriteria) {\n    return \"\".concat(groupingCriteria.field, \"/\").concat(groupingCriteria.key);\n  }).join('-');\n  return \"auto-generated-row-\".concat(pathStr);\n};\n/**\n * Transform a list of rows into a tree structure where each row references its parent and children.\n * If a row have a parent which does not exist in the input rows, creates an auto generated row\n *\n ```\n params = {\n   ids: [0, 1, 2],\n   idRowsLookup: { 0: {...}, 1: {...}, 2: {...} },\n   rows: [\n     { id: 0, path: ['A'] },\n     { id: 1, path: ['B', 'A'] },\n     { id: 2, path: ['B', 'A', 'A'] }\n   ],\n   defaultGroupingExpansionDepth: 0,\n }\n Returns:\n {\n   ids: [0, 1, 2, 'auto-generated-row-B'],\n   idRowsLookup: { 0: {...}, 1: {...}, 2: {...}, 'auto-generated-row-B': {} },\n   tree: {\n     '0': { id: 0, parent: null, childrenExpanded: false, depth: 0, groupingKey: 'A' },\n     'auto-generated-row-B': { id: 'auto-generated-row-B', parent: null, childrenExpanded: false, depth: 0, groupingKey: 'B' },\n     '1': { id: 1, parent: 'auto-generated-row-B', childrenExpanded: false, depth: 1, groupingKey: 'A' },\n     '2': { id: 2, parent: 1, childrenExpanded: false, depth: 2, groupingKey: 'A' },\n   },\n   treeDepth: 3,\n }\n ```\n */\n\nexport var buildRowTree = function buildRowTree(params) {\n  // During the build, we store the children as a Record to avoid linear complexity when checking if a children is already defined.\n  var tempTree = {};\n  var treeDepth = 1;\n  var ids = _toConsumableArray(params.ids);\n  var idRowsLookup = _extends({}, params.idRowsLookup);\n  var idToIdLookup = _extends({}, params.idToIdLookup);\n  var groupingCriteriaToIdTree = {};\n  var isGroupExpandedByDefault = function isGroupExpandedByDefault(node) {\n    var _params$previousTree, _params$previousTree$;\n    var previousExpansion = (_params$previousTree = params.previousTree) == null ? void 0 : (_params$previousTree$ = _params$previousTree[node.id]) == null ? void 0 : _params$previousTree$.childrenExpanded;\n    if (previousExpansion != null) {\n      return previousExpansion;\n    }\n    if (!node.children || !node.children.length) {\n      return undefined;\n    }\n    if (params.isGroupExpandedByDefault) {\n      return params.isGroupExpandedByDefault(node);\n    }\n    return params.defaultGroupingExpansionDepth === -1 || params.defaultGroupingExpansionDepth > node.depth;\n  };\n  for (var i = 0; i < params.rows.length; i += 1) {\n    var row = params.rows[i];\n    var keyToIdSubTree = groupingCriteriaToIdTree;\n    var parentNode = null;\n    for (var depth = 0; depth < row.path.length; depth += 1) {\n      var _row$path$depth = row.path[depth],\n        key = _row$path$depth.key,\n        rawField = _row$path$depth.field;\n      var field = rawField != null ? rawField : '__no_field__';\n      var nodeId = void 0;\n      var fieldSubTree = keyToIdSubTree[field];\n      if (!fieldSubTree) {\n        fieldSubTree = {};\n        keyToIdSubTree[field] = fieldSubTree;\n      }\n      var keyConfig = fieldSubTree[key.toString()];\n      if (keyConfig) {\n        if (depth === row.path.length - 1) {\n          var _params$onDuplicatePa;\n          (_params$onDuplicatePa = params.onDuplicatePath) == null ? void 0 : _params$onDuplicatePa.call(params, keyConfig.id, row.id, row.path);\n        }\n        nodeId = keyConfig.id;\n      } else {\n        if (depth === row.path.length - 1) {\n          nodeId = row.id;\n        } else {\n          nodeId = getGroupRowIdFromPath(row.path.slice(0, depth + 1));\n        }\n        keyConfig = {\n          id: nodeId,\n          children: {}\n        };\n        fieldSubTree[key.toString()] = keyConfig;\n      }\n      keyToIdSubTree = keyConfig.children;\n      if (!tempTree[nodeId]) {\n        var _parentNode$id, _parentNode;\n        var isAutoGenerated = depth < row.path.length - 1;\n        var node = {\n          id: nodeId,\n          isAutoGenerated: isAutoGenerated,\n          parent: (_parentNode$id = (_parentNode = parentNode) == null ? void 0 : _parentNode.id) != null ? _parentNode$id : null,\n          groupingKey: key,\n          groupingField: rawField,\n          depth: depth\n        };\n        if (isAutoGenerated) {\n          idRowsLookup[nodeId] = {};\n          ids.push(nodeId);\n        }\n        tempTree[nodeId] = node;\n      }\n      if (parentNode != null) {\n        if (!parentNode.children) {\n          parentNode.children = {};\n        }\n        parentNode.children[nodeId] = nodeId;\n      }\n      parentNode = tempTree[nodeId];\n    }\n    treeDepth = Math.max(treeDepth, row.path.length);\n  }\n  var tree = {};\n  var _loop = function _loop(_i) {\n    var rowId = ids[_i];\n    var tempNode = tempTree[rowId];\n    var nodeWithoutChildrenExpansion = _extends({}, tempNode, {\n      children: tempNode.children ? Object.values(tempNode.children) : undefined\n    });\n    var node = _extends({}, nodeWithoutChildrenExpansion, {\n      childrenExpanded: isGroupExpandedByDefault(nodeWithoutChildrenExpansion)\n    });\n    var previousNode = (_params$previousTree2 = params.previousTree) == null ? void 0 : _params$previousTree2[node.id];\n    var shouldReUsePreviousNode = previousNode && previousNode.isAutoGenerated === node.isAutoGenerated && previousNode.parent === node.parent && previousNode.groupingKey === node.groupingKey && previousNode.groupingField === node.groupingField && previousNode.depth === node.depth && previousNode.childrenExpanded === node.childrenExpanded && ((_previousNode$childre = previousNode.children) == null ? void 0 : _previousNode$childre.length) === ((_node$children = node.children) == null ? void 0 : _node$children.length) && ((_previousNode$childre2 = previousNode.children) == null ? void 0 : _previousNode$childre2.every(function (childId, index) {\n      var _node$children2;\n      return ((_node$children2 = node.children) == null ? void 0 : _node$children2[index]) === childId;\n    }));\n    if (shouldReUsePreviousNode) {\n      tree[rowId] = previousNode;\n    } else {\n      tree[rowId] = node;\n    }\n  };\n  for (var _i = 0; _i < ids.length; _i += 1) {\n    var _params$previousTree2, _previousNode$childre, _node$children, _previousNode$childre2;\n    _loop(_i);\n  }\n  return {\n    tree: tree,\n    treeDepth: treeDepth,\n    ids: ids,\n    idRowsLookup: idRowsLookup,\n    idToIdLookup: idToIdLookup,\n    groupingName: params.groupingName\n  };\n};","map":{"version":3,"names":["_extends","getGroupRowIdFromPath","path","pathStr","map","groupingCriteria","field","key","join","buildRowTree","params","tempTree","treeDepth","ids","idRowsLookup","idToIdLookup","groupingCriteriaToIdTree","isGroupExpandedByDefault","node","_params$previousTree","_params$previousTree$","previousExpansion","previousTree","id","childrenExpanded","children","length","undefined","defaultGroupingExpansionDepth","depth","i","rows","row","keyToIdSubTree","parentNode","rawField","nodeId","fieldSubTree","keyConfig","toString","_params$onDuplicatePa","onDuplicatePath","call","slice","_parentNode$id","_parentNode","isAutoGenerated","parent","groupingKey","groupingField","push","Math","max","tree","rowId","tempNode","nodeWithoutChildrenExpansion","Object","values","previousNode","_params$previousTree2","shouldReUsePreviousNode","_previousNode$childre","_node$children","_previousNode$childre2","every","childId","index","_node$children2","groupingName"],"sources":["/workspaces/Backwoodaroma/node_modules/@mui/x-data-grid-pro/utils/tree/buildRowTree.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nexport const getGroupRowIdFromPath = path => {\n  const pathStr = path.map(groupingCriteria => `${groupingCriteria.field}/${groupingCriteria.key}`).join('-');\n  return `auto-generated-row-${pathStr}`;\n};\n/**\n * Transform a list of rows into a tree structure where each row references its parent and children.\n * If a row have a parent which does not exist in the input rows, creates an auto generated row\n *\n ```\n params = {\n   ids: [0, 1, 2],\n   idRowsLookup: { 0: {...}, 1: {...}, 2: {...} },\n   rows: [\n     { id: 0, path: ['A'] },\n     { id: 1, path: ['B', 'A'] },\n     { id: 2, path: ['B', 'A', 'A'] }\n   ],\n   defaultGroupingExpansionDepth: 0,\n }\n Returns:\n {\n   ids: [0, 1, 2, 'auto-generated-row-B'],\n   idRowsLookup: { 0: {...}, 1: {...}, 2: {...}, 'auto-generated-row-B': {} },\n   tree: {\n     '0': { id: 0, parent: null, childrenExpanded: false, depth: 0, groupingKey: 'A' },\n     'auto-generated-row-B': { id: 'auto-generated-row-B', parent: null, childrenExpanded: false, depth: 0, groupingKey: 'B' },\n     '1': { id: 1, parent: 'auto-generated-row-B', childrenExpanded: false, depth: 1, groupingKey: 'A' },\n     '2': { id: 2, parent: 1, childrenExpanded: false, depth: 2, groupingKey: 'A' },\n   },\n   treeDepth: 3,\n }\n ```\n */\n\nexport const buildRowTree = params => {\n  // During the build, we store the children as a Record to avoid linear complexity when checking if a children is already defined.\n  const tempTree = {};\n  let treeDepth = 1;\n  const ids = [...params.ids];\n\n  const idRowsLookup = _extends({}, params.idRowsLookup);\n\n  const idToIdLookup = _extends({}, params.idToIdLookup);\n\n  const groupingCriteriaToIdTree = {};\n\n  const isGroupExpandedByDefault = node => {\n    var _params$previousTree, _params$previousTree$;\n\n    const previousExpansion = (_params$previousTree = params.previousTree) == null ? void 0 : (_params$previousTree$ = _params$previousTree[node.id]) == null ? void 0 : _params$previousTree$.childrenExpanded;\n\n    if (previousExpansion != null) {\n      return previousExpansion;\n    }\n\n    if (!node.children || !node.children.length) {\n      return undefined;\n    }\n\n    if (params.isGroupExpandedByDefault) {\n      return params.isGroupExpandedByDefault(node);\n    }\n\n    return params.defaultGroupingExpansionDepth === -1 || params.defaultGroupingExpansionDepth > node.depth;\n  };\n\n  for (let i = 0; i < params.rows.length; i += 1) {\n    const row = params.rows[i];\n    let keyToIdSubTree = groupingCriteriaToIdTree;\n    let parentNode = null;\n\n    for (let depth = 0; depth < row.path.length; depth += 1) {\n      const {\n        key,\n        field: rawField\n      } = row.path[depth];\n      const field = rawField != null ? rawField : '__no_field__';\n      let nodeId;\n      let fieldSubTree = keyToIdSubTree[field];\n\n      if (!fieldSubTree) {\n        fieldSubTree = {};\n        keyToIdSubTree[field] = fieldSubTree;\n      }\n\n      let keyConfig = fieldSubTree[key.toString()];\n\n      if (keyConfig) {\n        if (depth === row.path.length - 1) {\n          var _params$onDuplicatePa;\n\n          (_params$onDuplicatePa = params.onDuplicatePath) == null ? void 0 : _params$onDuplicatePa.call(params, keyConfig.id, row.id, row.path);\n        }\n\n        nodeId = keyConfig.id;\n      } else {\n        if (depth === row.path.length - 1) {\n          nodeId = row.id;\n        } else {\n          nodeId = getGroupRowIdFromPath(row.path.slice(0, depth + 1));\n        }\n\n        keyConfig = {\n          id: nodeId,\n          children: {}\n        };\n        fieldSubTree[key.toString()] = keyConfig;\n      }\n\n      keyToIdSubTree = keyConfig.children;\n\n      if (!tempTree[nodeId]) {\n        var _parentNode$id, _parentNode;\n\n        const isAutoGenerated = depth < row.path.length - 1;\n        const node = {\n          id: nodeId,\n          isAutoGenerated,\n          parent: (_parentNode$id = (_parentNode = parentNode) == null ? void 0 : _parentNode.id) != null ? _parentNode$id : null,\n          groupingKey: key,\n          groupingField: rawField,\n          depth\n        };\n\n        if (isAutoGenerated) {\n          idRowsLookup[nodeId] = {};\n          ids.push(nodeId);\n        }\n\n        tempTree[nodeId] = node;\n      }\n\n      if (parentNode != null) {\n        if (!parentNode.children) {\n          parentNode.children = {};\n        }\n\n        parentNode.children[nodeId] = nodeId;\n      }\n\n      parentNode = tempTree[nodeId];\n    }\n\n    treeDepth = Math.max(treeDepth, row.path.length);\n  }\n\n  const tree = {};\n\n  for (let i = 0; i < ids.length; i += 1) {\n    var _params$previousTree2, _previousNode$childre, _node$children, _previousNode$childre2;\n\n    const rowId = ids[i];\n    const tempNode = tempTree[rowId];\n\n    const nodeWithoutChildrenExpansion = _extends({}, tempNode, {\n      children: tempNode.children ? Object.values(tempNode.children) : undefined\n    });\n\n    const node = _extends({}, nodeWithoutChildrenExpansion, {\n      childrenExpanded: isGroupExpandedByDefault(nodeWithoutChildrenExpansion)\n    });\n\n    const previousNode = (_params$previousTree2 = params.previousTree) == null ? void 0 : _params$previousTree2[node.id];\n    const shouldReUsePreviousNode = previousNode && previousNode.isAutoGenerated === node.isAutoGenerated && previousNode.parent === node.parent && previousNode.groupingKey === node.groupingKey && previousNode.groupingField === node.groupingField && previousNode.depth === node.depth && previousNode.childrenExpanded === node.childrenExpanded && ((_previousNode$childre = previousNode.children) == null ? void 0 : _previousNode$childre.length) === ((_node$children = node.children) == null ? void 0 : _node$children.length) && ((_previousNode$childre2 = previousNode.children) == null ? void 0 : _previousNode$childre2.every((childId, index) => {\n      var _node$children2;\n\n      return ((_node$children2 = node.children) == null ? void 0 : _node$children2[index]) === childId;\n    }));\n\n    if (shouldReUsePreviousNode) {\n      tree[rowId] = previousNode;\n    } else {\n      tree[rowId] = node;\n    }\n  }\n\n  return {\n    tree,\n    treeDepth,\n    ids,\n    idRowsLookup,\n    idToIdLookup,\n    groupingName: params.groupingName\n  };\n};"],"mappings":";AAAA,OAAOA,QAAQ,MAAM,oCAAoC;AACzD,OAAO,IAAMC,qBAAqB,GAAG,SAAxBA,qBAAqB,CAAGC,IAAI,EAAI;EAC3C,IAAMC,OAAO,GAAGD,IAAI,CAACE,GAAG,CAAC,UAAAC,gBAAgB;IAAA,iBAAOA,gBAAgB,CAACC,KAAK,cAAID,gBAAgB,CAACE,GAAG;EAAA,CAAE,CAAC,CAACC,IAAI,CAAC,GAAG,CAAC;EAC3G,oCAA6BL,OAAO;AACtC,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,IAAMM,YAAY,GAAG,SAAfA,YAAY,CAAGC,MAAM,EAAI;EACpC;EACA,IAAMC,QAAQ,GAAG,CAAC,CAAC;EACnB,IAAIC,SAAS,GAAG,CAAC;EACjB,IAAMC,GAAG,sBAAOH,MAAM,CAACG,GAAG,CAAC;EAE3B,IAAMC,YAAY,GAAGd,QAAQ,CAAC,CAAC,CAAC,EAAEU,MAAM,CAACI,YAAY,CAAC;EAEtD,IAAMC,YAAY,GAAGf,QAAQ,CAAC,CAAC,CAAC,EAAEU,MAAM,CAACK,YAAY,CAAC;EAEtD,IAAMC,wBAAwB,GAAG,CAAC,CAAC;EAEnC,IAAMC,wBAAwB,GAAG,SAA3BA,wBAAwB,CAAGC,IAAI,EAAI;IACvC,IAAIC,oBAAoB,EAAEC,qBAAqB;IAE/C,IAAMC,iBAAiB,GAAG,CAACF,oBAAoB,GAAGT,MAAM,CAACY,YAAY,KAAK,IAAI,GAAG,KAAK,CAAC,GAAG,CAACF,qBAAqB,GAAGD,oBAAoB,CAACD,IAAI,CAACK,EAAE,CAAC,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGH,qBAAqB,CAACI,gBAAgB;IAE3M,IAAIH,iBAAiB,IAAI,IAAI,EAAE;MAC7B,OAAOA,iBAAiB;IAC1B;IAEA,IAAI,CAACH,IAAI,CAACO,QAAQ,IAAI,CAACP,IAAI,CAACO,QAAQ,CAACC,MAAM,EAAE;MAC3C,OAAOC,SAAS;IAClB;IAEA,IAAIjB,MAAM,CAACO,wBAAwB,EAAE;MACnC,OAAOP,MAAM,CAACO,wBAAwB,CAACC,IAAI,CAAC;IAC9C;IAEA,OAAOR,MAAM,CAACkB,6BAA6B,KAAK,CAAC,CAAC,IAAIlB,MAAM,CAACkB,6BAA6B,GAAGV,IAAI,CAACW,KAAK;EACzG,CAAC;EAED,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGpB,MAAM,CAACqB,IAAI,CAACL,MAAM,EAAEI,CAAC,IAAI,CAAC,EAAE;IAC9C,IAAME,GAAG,GAAGtB,MAAM,CAACqB,IAAI,CAACD,CAAC,CAAC;IAC1B,IAAIG,cAAc,GAAGjB,wBAAwB;IAC7C,IAAIkB,UAAU,GAAG,IAAI;IAErB,KAAK,IAAIL,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGG,GAAG,CAAC9B,IAAI,CAACwB,MAAM,EAAEG,KAAK,IAAI,CAAC,EAAE;MACvD,sBAGIG,GAAG,CAAC9B,IAAI,CAAC2B,KAAK,CAAC;QAFjBtB,GAAG,mBAAHA,GAAG;QACI4B,QAAQ,mBAAf7B,KAAK;MAEP,IAAMA,KAAK,GAAG6B,QAAQ,IAAI,IAAI,GAAGA,QAAQ,GAAG,cAAc;MAC1D,IAAIC,MAAM;MACV,IAAIC,YAAY,GAAGJ,cAAc,CAAC3B,KAAK,CAAC;MAExC,IAAI,CAAC+B,YAAY,EAAE;QACjBA,YAAY,GAAG,CAAC,CAAC;QACjBJ,cAAc,CAAC3B,KAAK,CAAC,GAAG+B,YAAY;MACtC;MAEA,IAAIC,SAAS,GAAGD,YAAY,CAAC9B,GAAG,CAACgC,QAAQ,EAAE,CAAC;MAE5C,IAAID,SAAS,EAAE;QACb,IAAIT,KAAK,KAAKG,GAAG,CAAC9B,IAAI,CAACwB,MAAM,GAAG,CAAC,EAAE;UACjC,IAAIc,qBAAqB;UAEzB,CAACA,qBAAqB,GAAG9B,MAAM,CAAC+B,eAAe,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGD,qBAAqB,CAACE,IAAI,CAAChC,MAAM,EAAE4B,SAAS,CAACf,EAAE,EAAES,GAAG,CAACT,EAAE,EAAES,GAAG,CAAC9B,IAAI,CAAC;QACxI;QAEAkC,MAAM,GAAGE,SAAS,CAACf,EAAE;MACvB,CAAC,MAAM;QACL,IAAIM,KAAK,KAAKG,GAAG,CAAC9B,IAAI,CAACwB,MAAM,GAAG,CAAC,EAAE;UACjCU,MAAM,GAAGJ,GAAG,CAACT,EAAE;QACjB,CAAC,MAAM;UACLa,MAAM,GAAGnC,qBAAqB,CAAC+B,GAAG,CAAC9B,IAAI,CAACyC,KAAK,CAAC,CAAC,EAAEd,KAAK,GAAG,CAAC,CAAC,CAAC;QAC9D;QAEAS,SAAS,GAAG;UACVf,EAAE,EAAEa,MAAM;UACVX,QAAQ,EAAE,CAAC;QACb,CAAC;QACDY,YAAY,CAAC9B,GAAG,CAACgC,QAAQ,EAAE,CAAC,GAAGD,SAAS;MAC1C;MAEAL,cAAc,GAAGK,SAAS,CAACb,QAAQ;MAEnC,IAAI,CAACd,QAAQ,CAACyB,MAAM,CAAC,EAAE;QACrB,IAAIQ,cAAc,EAAEC,WAAW;QAE/B,IAAMC,eAAe,GAAGjB,KAAK,GAAGG,GAAG,CAAC9B,IAAI,CAACwB,MAAM,GAAG,CAAC;QACnD,IAAMR,IAAI,GAAG;UACXK,EAAE,EAAEa,MAAM;UACVU,eAAe,EAAfA,eAAe;UACfC,MAAM,EAAE,CAACH,cAAc,GAAG,CAACC,WAAW,GAAGX,UAAU,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGW,WAAW,CAACtB,EAAE,KAAK,IAAI,GAAGqB,cAAc,GAAG,IAAI;UACvHI,WAAW,EAAEzC,GAAG;UAChB0C,aAAa,EAAEd,QAAQ;UACvBN,KAAK,EAALA;QACF,CAAC;QAED,IAAIiB,eAAe,EAAE;UACnBhC,YAAY,CAACsB,MAAM,CAAC,GAAG,CAAC,CAAC;UACzBvB,GAAG,CAACqC,IAAI,CAACd,MAAM,CAAC;QAClB;QAEAzB,QAAQ,CAACyB,MAAM,CAAC,GAAGlB,IAAI;MACzB;MAEA,IAAIgB,UAAU,IAAI,IAAI,EAAE;QACtB,IAAI,CAACA,UAAU,CAACT,QAAQ,EAAE;UACxBS,UAAU,CAACT,QAAQ,GAAG,CAAC,CAAC;QAC1B;QAEAS,UAAU,CAACT,QAAQ,CAACW,MAAM,CAAC,GAAGA,MAAM;MACtC;MAEAF,UAAU,GAAGvB,QAAQ,CAACyB,MAAM,CAAC;IAC/B;IAEAxB,SAAS,GAAGuC,IAAI,CAACC,GAAG,CAACxC,SAAS,EAAEoB,GAAG,CAAC9B,IAAI,CAACwB,MAAM,CAAC;EAClD;EAEA,IAAM2B,IAAI,GAAG,CAAC,CAAC;EAAC,2BAEPvB,EAAC;IAGR,IAAMwB,KAAK,GAAGzC,GAAG,CAACiB,EAAC,CAAC;IACpB,IAAMyB,QAAQ,GAAG5C,QAAQ,CAAC2C,KAAK,CAAC;IAEhC,IAAME,4BAA4B,GAAGxD,QAAQ,CAAC,CAAC,CAAC,EAAEuD,QAAQ,EAAE;MAC1D9B,QAAQ,EAAE8B,QAAQ,CAAC9B,QAAQ,GAAGgC,MAAM,CAACC,MAAM,CAACH,QAAQ,CAAC9B,QAAQ,CAAC,GAAGE;IACnE,CAAC,CAAC;IAEF,IAAMT,IAAI,GAAGlB,QAAQ,CAAC,CAAC,CAAC,EAAEwD,4BAA4B,EAAE;MACtDhC,gBAAgB,EAAEP,wBAAwB,CAACuC,4BAA4B;IACzE,CAAC,CAAC;IAEF,IAAMG,YAAY,GAAG,CAACC,qBAAqB,GAAGlD,MAAM,CAACY,YAAY,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGsC,qBAAqB,CAAC1C,IAAI,CAACK,EAAE,CAAC;IACpH,IAAMsC,uBAAuB,GAAGF,YAAY,IAAIA,YAAY,CAACb,eAAe,KAAK5B,IAAI,CAAC4B,eAAe,IAAIa,YAAY,CAACZ,MAAM,KAAK7B,IAAI,CAAC6B,MAAM,IAAIY,YAAY,CAACX,WAAW,KAAK9B,IAAI,CAAC8B,WAAW,IAAIW,YAAY,CAACV,aAAa,KAAK/B,IAAI,CAAC+B,aAAa,IAAIU,YAAY,CAAC9B,KAAK,KAAKX,IAAI,CAACW,KAAK,IAAI8B,YAAY,CAACnC,gBAAgB,KAAKN,IAAI,CAACM,gBAAgB,IAAI,CAAC,CAACsC,qBAAqB,GAAGH,YAAY,CAAClC,QAAQ,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGqC,qBAAqB,CAACpC,MAAM,OAAO,CAACqC,cAAc,GAAG7C,IAAI,CAACO,QAAQ,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGsC,cAAc,CAACrC,MAAM,CAAC,KAAK,CAACsC,sBAAsB,GAAGL,YAAY,CAAClC,QAAQ,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGuC,sBAAsB,CAACC,KAAK,CAAC,UAACC,OAAO,EAAEC,KAAK,EAAK;MAC/nB,IAAIC,eAAe;MAEnB,OAAO,CAAC,CAACA,eAAe,GAAGlD,IAAI,CAACO,QAAQ,KAAK,IAAI,GAAG,KAAK,CAAC,GAAG2C,eAAe,CAACD,KAAK,CAAC,MAAMD,OAAO;IAClG,CAAC,CAAC,CAAC;IAEH,IAAIL,uBAAuB,EAAE;MAC3BR,IAAI,CAACC,KAAK,CAAC,GAAGK,YAAY;IAC5B,CAAC,MAAM;MACLN,IAAI,CAACC,KAAK,CAAC,GAAGpC,IAAI;IACpB;EAAC;EAzBH,KAAK,IAAIY,EAAC,GAAG,CAAC,EAAEA,EAAC,GAAGjB,GAAG,CAACa,MAAM,EAAEI,EAAC,IAAI,CAAC,EAAE;IAAA,IAClC8B,qBAAqB,EAAEE,qBAAqB,EAAEC,cAAc,EAAEC,sBAAsB;IAAA,MADjFlC,EAAC;EA0BV;EAEA,OAAO;IACLuB,IAAI,EAAJA,IAAI;IACJzC,SAAS,EAATA,SAAS;IACTC,GAAG,EAAHA,GAAG;IACHC,YAAY,EAAZA,YAAY;IACZC,YAAY,EAAZA,YAAY;IACZsD,YAAY,EAAE3D,MAAM,CAAC2D;EACvB,CAAC;AACH,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}